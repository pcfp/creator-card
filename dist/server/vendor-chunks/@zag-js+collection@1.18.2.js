"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zag-js+collection@1.18.2";
exports.ids = ["vendor-chunks/@zag-js+collection@1.18.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@zag-js+collection@1.18.2/node_modules/@zag-js/collection/dist/index.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zag-js+collection@1.18.2/node_modules/@zag-js/collection/dist/index.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridCollection: () => (/* binding */ GridCollection),\n/* harmony export */   ListCollection: () => (/* binding */ ListCollection),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   TreeCollection: () => (/* binding */ TreeCollection),\n/* harmony export */   filePathToTree: () => (/* binding */ filePathToTree),\n/* harmony export */   flattenedToTree: () => (/* binding */ flattenedToTree),\n/* harmony export */   isGridCollection: () => (/* binding */ isGridCollection),\n/* harmony export */   isListCollection: () => (/* binding */ isListCollection)\n/* harmony export */ });\n/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/utils */ \"(ssr)/./node_modules/.pnpm/@zag-js+utils@1.18.2/node_modules/@zag-js/utils/dist/index.mjs\");\n\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar fallback = {\n  itemToValue(item) {\n    if (typeof item === \"string\") return item;\n    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(item) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(item, \"value\")) return item.value;\n    return \"\";\n  },\n  itemToString(item) {\n    if (typeof item === \"string\") return item;\n    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(item) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(item, \"label\")) return item.label;\n    return fallback.itemToValue(item);\n  },\n  isItemDisabled(item) {\n    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(item) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(item, \"disabled\")) return !!item.disabled;\n    return false;\n  }\n};\nvar ListCollection = class _ListCollection {\n  constructor(options) {\n    this.options = options;\n    /**\n     * The items in the collection\n     */\n    __publicField(this, \"items\");\n    /**\n     * Copy the collection\n     */\n    __publicField(this, \"copy\", (items) => {\n      return new _ListCollection({ ...this.options, items: items ?? [...this.items] });\n    });\n    /**\n     * Check if the collection is equal to another collection\n     */\n    __publicField(this, \"isEqual\", (other) => {\n      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isEqual)(this.items, other.items);\n    });\n    /**\n     * Function to update the collection items\n     */\n    __publicField(this, \"setItems\", (items) => {\n      return this.copy(items);\n    });\n    /**\n     * Returns all the values in the collection\n     */\n    __publicField(this, \"getValues\", (items = this.items) => {\n      return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);\n    });\n    /**\n     * Get the item based on its value\n     */\n    __publicField(this, \"find\", (value) => {\n      if (value == null) return null;\n      const index = this.indexOf(value);\n      return index != null ? this.at(index) : null;\n    });\n    /**\n     * Get the items based on its values\n     */\n    __publicField(this, \"findMany\", (values) => {\n      return Array.from(values).map((value) => this.find(value)).filter((item) => item != null);\n    });\n    /**\n     * Get the item based on its index\n     */\n    __publicField(this, \"at\", (index) => {\n      if (!this.options.groupBy && !this.options.groupSort) {\n        return this.items[index] ?? null;\n      }\n      let idx = 0;\n      const groups = this.group();\n      for (const [, items] of groups) {\n        for (const item of items) {\n          if (idx === index) return item;\n          idx++;\n        }\n      }\n      return null;\n    });\n    __publicField(this, \"sortFn\", (valueA, valueB) => {\n      const indexA = this.indexOf(valueA);\n      const indexB = this.indexOf(valueB);\n      return (indexA ?? 0) - (indexB ?? 0);\n    });\n    /**\n     * Sort the values based on their index\n     */\n    __publicField(this, \"sort\", (values) => {\n      return [...values].sort(this.sortFn.bind(this));\n    });\n    /**\n     * Convert an item to a value\n     */\n    __publicField(this, \"getItemValue\", (item) => {\n      if (item == null) return null;\n      return this.options.itemToValue?.(item) ?? fallback.itemToValue(item);\n    });\n    /**\n     * Whether an item is disabled\n     */\n    __publicField(this, \"getItemDisabled\", (item) => {\n      if (item == null) return false;\n      return this.options.isItemDisabled?.(item) ?? fallback.isItemDisabled(item);\n    });\n    /**\n     * Convert an item to a string\n     */\n    __publicField(this, \"stringifyItem\", (item) => {\n      if (item == null) return null;\n      return this.options.itemToString?.(item) ?? fallback.itemToString(item);\n    });\n    /**\n     * Convert a value to a string\n     */\n    __publicField(this, \"stringify\", (value) => {\n      if (value == null) return null;\n      return this.stringifyItem(this.find(value));\n    });\n    /**\n     * Convert an array of items to a string\n     */\n    __publicField(this, \"stringifyItems\", (items, separator = \", \") => {\n      return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);\n    });\n    /**\n     * Convert an array of items to a string\n     */\n    __publicField(this, \"stringifyMany\", (value, separator) => {\n      return this.stringifyItems(this.findMany(value), separator);\n    });\n    /**\n     * Whether the collection has a value\n     */\n    __publicField(this, \"has\", (value) => {\n      return this.indexOf(value) !== -1;\n    });\n    /**\n     * Whether the collection has an item\n     */\n    __publicField(this, \"hasItem\", (item) => {\n      if (item == null) return false;\n      return this.has(this.getItemValue(item));\n    });\n    /**\n     * Group items by the groupBy function provided in options\n     * Returns an array of [groupKey, items] tuples\n     */\n    __publicField(this, \"group\", () => {\n      const { groupBy, groupSort } = this.options;\n      if (!groupBy) return [[\"\", [...this.items]]];\n      const groups = /* @__PURE__ */ new Map();\n      this.items.forEach((item, index) => {\n        const groupKey = groupBy(item, index);\n        if (!groups.has(groupKey)) {\n          groups.set(groupKey, []);\n        }\n        groups.get(groupKey).push(item);\n      });\n      let entries = Array.from(groups.entries());\n      if (groupSort) {\n        entries.sort(([a], [b]) => {\n          if (typeof groupSort === \"function\") return groupSort(a, b);\n          if (Array.isArray(groupSort)) {\n            const indexA = groupSort.indexOf(a);\n            const indexB = groupSort.indexOf(b);\n            if (indexA === -1) return 1;\n            if (indexB === -1) return -1;\n            return indexA - indexB;\n          }\n          if (groupSort === \"asc\") return a.localeCompare(b);\n          if (groupSort === \"desc\") return b.localeCompare(a);\n          return 0;\n        });\n      }\n      return entries;\n    });\n    /**\n     * Returns the next value in the collection\n     */\n    __publicField(this, \"getNextValue\", (value, step = 1, clamp = false) => {\n      let index = this.indexOf(value);\n      if (index === -1) return null;\n      index = clamp ? Math.min(index + step, this.size - 1) : index + step;\n      while (index <= this.size && this.getItemDisabled(this.at(index))) index++;\n      return this.getItemValue(this.at(index));\n    });\n    /**\n     * Returns the previous value in the collection\n     */\n    __publicField(this, \"getPreviousValue\", (value, step = 1, clamp = false) => {\n      let index = this.indexOf(value);\n      if (index === -1) return null;\n      index = clamp ? Math.max(index - step, 0) : index - step;\n      while (index >= 0 && this.getItemDisabled(this.at(index))) index--;\n      return this.getItemValue(this.at(index));\n    });\n    /**\n     * Get the index of an item based on its key\n     */\n    __publicField(this, \"indexOf\", (value) => {\n      if (value == null) return -1;\n      if (!this.options.groupBy && !this.options.groupSort) {\n        return this.items.findIndex((item) => this.getItemValue(item) === value);\n      }\n      let idx = 0;\n      const groups = this.group();\n      for (const [, items] of groups) {\n        for (const item of items) {\n          if (this.getItemValue(item) === value) return idx;\n          idx++;\n        }\n      }\n      return -1;\n    });\n    __publicField(this, \"getByText\", (text, current) => {\n      let items = current != null ? wrap(this.items, this.indexOf(current)) : this.items;\n      const isSingleKey = text.length === 1;\n      if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);\n      return items.find((item) => match(this.stringifyItem(item), text));\n    });\n    /**\n     * Search for a value based on a query\n     */\n    __publicField(this, \"search\", (queryString, options) => {\n      const { state, currentValue, timeout = 350 } = options;\n      const search = state.keysSoFar + queryString;\n      const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n      const query = isRepeated ? search[0] : search;\n      const item = this.getByText(query, currentValue);\n      const value = this.getItemValue(item);\n      function cleanup() {\n        clearTimeout(state.timer);\n        state.timer = -1;\n      }\n      function update(value2) {\n        state.keysSoFar = value2;\n        cleanup();\n        if (value2 !== \"\") {\n          state.timer = +setTimeout(() => {\n            update(\"\");\n            cleanup();\n          }, timeout);\n        }\n      }\n      update(search);\n      return value;\n    });\n    /**\n     * Update an item in the collection\n     */\n    __publicField(this, \"update\", (value, item) => {\n      let index = this.indexOf(value);\n      if (index === -1) return this;\n      return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);\n    });\n    /**\n     * Update an item in the collection if it exists, otherwise append it\n     */\n    __publicField(this, \"upsert\", (value, item, mode = \"append\") => {\n      let index = this.indexOf(value);\n      if (index === -1) {\n        const fn = mode === \"append\" ? this.append : this.prepend;\n        return fn(item);\n      }\n      return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);\n    });\n    /**\n     * Insert items at a specific index\n     */\n    __publicField(this, \"insert\", (index, ...items) => {\n      return this.copy(insert(this.items, index, ...items));\n    });\n    /**\n     * Insert items before a specific value\n     */\n    __publicField(this, \"insertBefore\", (value, ...items) => {\n      let toIndex = this.indexOf(value);\n      if (toIndex === -1) {\n        if (this.items.length === 0) toIndex = 0;\n        else return this;\n      }\n      return this.copy(insert(this.items, toIndex, ...items));\n    });\n    /**\n     * Insert items after a specific value\n     */\n    __publicField(this, \"insertAfter\", (value, ...items) => {\n      let toIndex = this.indexOf(value);\n      if (toIndex === -1) {\n        if (this.items.length === 0) toIndex = 0;\n        else return this;\n      }\n      return this.copy(insert(this.items, toIndex + 1, ...items));\n    });\n    /**\n     * Prepend items to the collection\n     */\n    __publicField(this, \"prepend\", (...items) => {\n      return this.copy(insert(this.items, 0, ...items));\n    });\n    /**\n     * Append items to the collection\n     */\n    __publicField(this, \"append\", (...items) => {\n      return this.copy(insert(this.items, this.items.length, ...items));\n    });\n    /**\n     * Filter the collection\n     */\n    __publicField(this, \"filter\", (fn) => {\n      const filteredItems = this.items.filter((item, index) => fn(this.stringifyItem(item), index, item));\n      return this.copy(filteredItems);\n    });\n    /**\n     * Remove items from the collection\n     */\n    __publicField(this, \"remove\", (...itemsOrValues) => {\n      const values = itemsOrValues.map(\n        (itemOrValue) => typeof itemOrValue === \"string\" ? itemOrValue : this.getItemValue(itemOrValue)\n      );\n      return this.copy(\n        this.items.filter((item) => {\n          const value = this.getItemValue(item);\n          if (value == null) return false;\n          return !values.includes(value);\n        })\n      );\n    });\n    /**\n     * Move an item to a specific index\n     */\n    __publicField(this, \"move\", (value, toIndex) => {\n      const fromIndex = this.indexOf(value);\n      if (fromIndex === -1) return this;\n      return this.copy(move(this.items, [fromIndex], toIndex));\n    });\n    /**\n     * Move items before a specific value\n     */\n    __publicField(this, \"moveBefore\", (value, ...values) => {\n      let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);\n      if (toIndex === -1) return this;\n      let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a, b) => a - b);\n      return this.copy(move(this.items, indices, toIndex));\n    });\n    /**\n     * Move items after a specific value\n     */\n    __publicField(this, \"moveAfter\", (value, ...values) => {\n      let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);\n      if (toIndex === -1) return this;\n      let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a, b) => a - b);\n      return this.copy(move(this.items, indices, toIndex + 1));\n    });\n    /**\n     * Reorder items\n     */\n    __publicField(this, \"reorder\", (fromIndex, toIndex) => {\n      return this.copy(move(this.items, [fromIndex], toIndex));\n    });\n    /**\n     * Compare two values\n     */\n    __publicField(this, \"compareValue\", (a, b) => {\n      const indexA = this.indexOf(a);\n      const indexB = this.indexOf(b);\n      if (indexA < indexB) return -1;\n      if (indexA > indexB) return 1;\n      return 0;\n    });\n    /**\n     * Get the range of values between two values\n     */\n    __publicField(this, \"range\", (from, to) => {\n      let keys = [];\n      let key = from;\n      while (key != null) {\n        let item = this.find(key);\n        if (item) keys.push(key);\n        if (key === to) return keys;\n        key = this.getNextValue(key);\n      }\n      return [];\n    });\n    /**\n     * Get the range of values between two values\n     */\n    __publicField(this, \"getValueRange\", (from, to) => {\n      if (from && to) {\n        if (this.compareValue(from, to) <= 0) {\n          return this.range(from, to);\n        }\n        return this.range(to, from);\n      }\n      return [];\n    });\n    /**\n     * Convert the collection to a string\n     */\n    __publicField(this, \"toString\", () => {\n      let result = \"\";\n      for (const item of this.items) {\n        const value = this.getItemValue(item);\n        const label = this.stringifyItem(item);\n        const disabled = this.getItemDisabled(item);\n        const itemString = [value, label, disabled].filter(Boolean).join(\":\");\n        result += itemString + \",\";\n      }\n      return result;\n    });\n    /**\n     * Convert the collection to a JSON object\n     */\n    __publicField(this, \"toJSON\", () => {\n      return {\n        size: this.size,\n        first: this.firstValue,\n        last: this.lastValue\n      };\n    });\n    this.items = [...options.items];\n  }\n  /**\n   * Returns the number of items in the collection\n   */\n  get size() {\n    return this.items.length;\n  }\n  /**\n   * Returns the first value in the collection\n   */\n  get firstValue() {\n    let index = 0;\n    while (this.getItemDisabled(this.at(index))) index++;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Returns the last value in the collection\n   */\n  get lastValue() {\n    let index = this.size - 1;\n    while (this.getItemDisabled(this.at(index))) index--;\n    return this.getItemValue(this.at(index));\n  }\n  *[Symbol.iterator]() {\n    yield* this.items;\n  }\n};\nvar match = (label, query) => {\n  return !!label?.toLowerCase().startsWith(query.toLowerCase());\n};\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nfunction isListCollection(v) {\n  return v instanceof ListCollection;\n}\nfunction insert(items, index, ...values) {\n  return [...items.slice(0, index), ...values, ...items.slice(index)];\n}\nfunction move(items, indices, toIndex) {\n  indices = [...indices].sort((a, b) => a - b);\n  const itemsToMove = indices.map((i) => items[i]);\n  for (let i = indices.length - 1; i >= 0; i--) {\n    items = [...items.slice(0, indices[i]), ...items.slice(indices[i] + 1)];\n  }\n  toIndex = Math.max(0, toIndex - indices.filter((i) => i < toIndex).length);\n  return [...items.slice(0, toIndex), ...itemsToMove, ...items.slice(toIndex)];\n}\n\n// src/grid-collection.ts\nvar GridCollection = class extends ListCollection {\n  constructor(options) {\n    const { columnCount } = options;\n    super(options);\n    __publicField(this, \"columnCount\");\n    /**\n     * Returns the row data in the grid\n     */\n    __publicField(this, \"getRows\", () => {\n      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.chunk)([...this.items], this.columnCount);\n    });\n    /**\n     * Returns the number of rows in the grid\n     */\n    __publicField(this, \"getRowCount\", () => {\n      return this.getRows().length;\n    });\n    /**\n     * Returns the index of the specified row and column in the grid\n     */\n    __publicField(this, \"getCellIndex\", (row, column) => {\n      return row * this.columnCount + column;\n    });\n    /**\n     * Returns the item at the specified row and column in the grid\n     */\n    __publicField(this, \"getCell\", (row, column) => {\n      return this.at(this.getCellIndex(row, column));\n    });\n    /**\n     * Returns the row and column index for a given value\n     */\n    __publicField(this, \"getValueCell\", (value) => {\n      const index = this.indexOf(value);\n      if (index === -1) return null;\n      const row = Math.floor(index / this.columnCount);\n      const column = index % this.columnCount;\n      return { row, column };\n    });\n    /**\n     * Returns the value of the last enabled column in a row\n     */\n    __publicField(this, \"getLastEnabledColumnIndex\", (row) => {\n      for (let col = this.columnCount - 1; col >= 0; col--) {\n        const cell = this.getCell(row, col);\n        if (cell && !this.getItemDisabled(cell)) {\n          return col;\n        }\n      }\n      return null;\n    });\n    /**\n     * Returns the index of the first enabled column in a row\n     */\n    __publicField(this, \"getFirstEnabledColumnIndex\", (row) => {\n      for (let col = 0; col < this.columnCount; col++) {\n        const cell = this.getCell(row, col);\n        if (cell && !this.getItemDisabled(cell)) {\n          return col;\n        }\n      }\n      return null;\n    });\n    /**\n     * Returns the value of the previous row in the grid, based on the current value\n     */\n    __publicField(this, \"getPreviousRowValue\", (value, loop = false) => {\n      const currentCell = this.getValueCell(value);\n      if (currentCell === null) return null;\n      const rows = this.getRows();\n      const rowCount = this.getRowCount();\n      let prevRowIndex = currentCell.row;\n      let prevColumnIndex = currentCell.column;\n      for (let i = 1; i <= rowCount; i++) {\n        prevRowIndex = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.prevIndex)(rows, prevRowIndex, { loop });\n        const prevRow = rows[prevRowIndex];\n        if (!prevRow) continue;\n        const prevCell = prevRow[prevColumnIndex];\n        if (!prevCell) {\n          const lastColumnIndex = this.getLastEnabledColumnIndex(prevRowIndex);\n          if (lastColumnIndex != null) {\n            prevColumnIndex = lastColumnIndex;\n          }\n        }\n        const cell = this.getCell(prevRowIndex, prevColumnIndex);\n        if (!this.getItemDisabled(cell)) {\n          return this.getItemValue(cell);\n        }\n      }\n      return this.firstValue;\n    });\n    /**\n     * Returns the value of the next row in the grid, based on the current value\n     */\n    __publicField(this, \"getNextRowValue\", (value, loop = false) => {\n      const currentCell = this.getValueCell(value);\n      if (currentCell === null) return null;\n      const rows = this.getRows();\n      const rowCount = this.getRowCount();\n      let nextRowIndex = currentCell.row;\n      let nextColumnIndex = currentCell.column;\n      for (let i = 1; i <= rowCount; i++) {\n        nextRowIndex = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.nextIndex)(rows, nextRowIndex, { loop });\n        const nextRow = rows[nextRowIndex];\n        if (!nextRow) continue;\n        const nextCell = nextRow[nextColumnIndex];\n        if (!nextCell) {\n          const lastColumnIndex = this.getLastEnabledColumnIndex(nextRowIndex);\n          if (lastColumnIndex != null) {\n            nextColumnIndex = lastColumnIndex;\n          }\n        }\n        const cell = this.getCell(nextRowIndex, nextColumnIndex);\n        if (!this.getItemDisabled(cell)) {\n          return this.getItemValue(cell);\n        }\n      }\n      return this.lastValue;\n    });\n    this.columnCount = columnCount;\n  }\n};\nfunction isGridCollection(v) {\n  return v instanceof GridCollection;\n}\nvar Selection = class _Selection extends Set {\n  constructor(values = []) {\n    super(values);\n    __publicField(this, \"selectionMode\", \"single\");\n    __publicField(this, \"deselectable\", true);\n    __publicField(this, \"copy\", () => {\n      const clone = new _Selection([...this]);\n      return this.sync(clone);\n    });\n    __publicField(this, \"sync\", (other) => {\n      other.selectionMode = this.selectionMode;\n      other.deselectable = this.deselectable;\n      return other;\n    });\n    __publicField(this, \"isEmpty\", () => {\n      return this.size === 0;\n    });\n    __publicField(this, \"isSelected\", (value) => {\n      if (this.selectionMode === \"none\" || value == null) {\n        return false;\n      }\n      return this.has(value);\n    });\n    __publicField(this, \"canSelect\", (collection, value) => {\n      return this.selectionMode !== \"none\" || !collection.getItemDisabled(collection.find(value));\n    });\n    __publicField(this, \"firstSelectedValue\", (collection) => {\n      let firstValue = null;\n      for (let value of this) {\n        if (!firstValue || collection.compareValue(value, firstValue) < 0) {\n          firstValue = value;\n        }\n      }\n      return firstValue;\n    });\n    __publicField(this, \"lastSelectedValue\", (collection) => {\n      let lastValue = null;\n      for (let value of this) {\n        if (!lastValue || collection.compareValue(value, lastValue) > 0) {\n          lastValue = value;\n        }\n      }\n      return lastValue;\n    });\n    __publicField(this, \"extendSelection\", (collection, anchorValue, targetValue) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (this.selectionMode === \"single\") {\n        return this.replaceSelection(collection, targetValue);\n      }\n      const selection = this.copy();\n      const lastSelected = Array.from(this).pop();\n      for (let key of collection.getValueRange(anchorValue, lastSelected ?? targetValue)) {\n        selection.delete(key);\n      }\n      for (let key of collection.getValueRange(targetValue, anchorValue)) {\n        if (this.canSelect(collection, key)) {\n          selection.add(key);\n        }\n      }\n      return selection;\n    });\n    __publicField(this, \"toggleSelection\", (collection, value) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (this.selectionMode === \"single\" && !this.isSelected(value)) {\n        return this.replaceSelection(collection, value);\n      }\n      const selection = this.copy();\n      if (selection.has(value)) {\n        selection.delete(value);\n      } else if (selection.canSelect(collection, value)) {\n        selection.add(value);\n      }\n      return selection;\n    });\n    __publicField(this, \"replaceSelection\", (collection, value) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (value == null) {\n        return this;\n      }\n      if (!this.canSelect(collection, value)) {\n        return this;\n      }\n      const selection = new _Selection([value]);\n      return this.sync(selection);\n    });\n    __publicField(this, \"setSelection\", (values) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      let selection = new _Selection();\n      for (let value of values) {\n        if (value != null) {\n          selection.add(value);\n          if (this.selectionMode === \"single\") {\n            break;\n          }\n        }\n      }\n      return this.sync(selection);\n    });\n    __publicField(this, \"clearSelection\", () => {\n      const selection = this.copy();\n      if (selection.deselectable && selection.size > 0) {\n        selection.clear();\n      }\n      return selection;\n    });\n    __publicField(this, \"select\", (collection, value, forceToggle) => {\n      if (this.selectionMode === \"none\") {\n        return this;\n      }\n      if (this.selectionMode === \"single\") {\n        if (this.isSelected(value) && this.deselectable) {\n          return this.toggleSelection(collection, value);\n        } else {\n          return this.replaceSelection(collection, value);\n        }\n      } else if (this.selectionMode === \"multiple\" || forceToggle) {\n        return this.toggleSelection(collection, value);\n      } else {\n        return this.replaceSelection(collection, value);\n      }\n    });\n    __publicField(this, \"deselect\", (value) => {\n      const selection = this.copy();\n      selection.delete(value);\n      return selection;\n    });\n    __publicField(this, \"isEqual\", (other) => {\n      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isEqual)(Array.from(this), Array.from(other));\n    });\n  }\n};\n\n// src/tree-visit.ts\nfunction access(node, indexPath, options) {\n  for (let i = 0; i < indexPath.length; i++) node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];\n  return node;\n}\nfunction ancestorIndexPaths(indexPaths) {\n  const sortedPaths = sortIndexPaths(indexPaths);\n  const result = [];\n  const seen = /* @__PURE__ */ new Set();\n  for (const indexPath of sortedPaths) {\n    const key = indexPath.join();\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(indexPath);\n    }\n  }\n  return result;\n}\nfunction compareIndexPaths(a, b) {\n  for (let i = 0; i < Math.min(a.length, b.length); i++) {\n    if (a[i] < b[i]) return -1;\n    if (a[i] > b[i]) return 1;\n  }\n  return a.length - b.length;\n}\nfunction sortIndexPaths(indexPaths) {\n  return indexPaths.sort(compareIndexPaths);\n}\nfunction find(node, options) {\n  let found;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = child;\n        return \"stop\";\n      }\n    }\n  });\n  return found;\n}\nfunction findAll(node, options) {\n  const found = [];\n  visit(node, {\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) found.push(child);\n    },\n    getChildren: options.getChildren\n  });\n  return found;\n}\nfunction findIndexPath(node, options) {\n  let found;\n  visit(node, {\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = [...indexPath];\n        return \"stop\";\n      }\n    },\n    getChildren: options.getChildren\n  });\n  return found;\n}\nfunction reduce(node, options) {\n  let result = options.initialResult;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      result = options.nextResult(result, child, indexPath);\n    }\n  });\n  return result;\n}\nfunction flatMap(node, options) {\n  return reduce(node, {\n    ...options,\n    initialResult: [],\n    nextResult: (result, child, indexPath) => {\n      result.push(...options.transform(child, indexPath));\n      return result;\n    }\n  });\n}\nfunction filter(node, options) {\n  const { predicate, create, getChildren } = options;\n  const filterRecursive = (node2, indexPath) => {\n    const children = getChildren(node2, indexPath);\n    const filteredChildren = [];\n    children.forEach((child, index) => {\n      const childIndexPath = [...indexPath, index];\n      const filteredChild = filterRecursive(child, childIndexPath);\n      if (filteredChild) filteredChildren.push(filteredChild);\n    });\n    const isRoot = indexPath.length === 0;\n    const nodeMatches = predicate(node2, indexPath);\n    const hasFilteredChildren = filteredChildren.length > 0;\n    if (isRoot || nodeMatches || hasFilteredChildren) {\n      return create(node2, filteredChildren, indexPath);\n    }\n    return null;\n  };\n  return filterRecursive(node, []) || create(node, [], []);\n}\nfunction flatten(rootNode, options) {\n  const nodes = [];\n  let idx = 0;\n  const idxMap = /* @__PURE__ */ new Map();\n  const parentMap = /* @__PURE__ */ new Map();\n  visit(rootNode, {\n    getChildren: options.getChildren,\n    onEnter: (node, indexPath) => {\n      if (!idxMap.has(node)) {\n        idxMap.set(node, idx++);\n      }\n      const children = options.getChildren(node, indexPath);\n      children.forEach((child) => {\n        if (!parentMap.has(child)) {\n          parentMap.set(child, node);\n        }\n        if (!idxMap.has(child)) {\n          idxMap.set(child, idx++);\n        }\n      });\n      const _children = children.length > 0 ? children.map((child) => idxMap.get(child)) : void 0;\n      const parent = parentMap.get(node);\n      const _parent = parent ? idxMap.get(parent) : void 0;\n      const _index = idxMap.get(node);\n      nodes.push({ ...node, _children, _parent, _index });\n    }\n  });\n  return nodes;\n}\nfunction insertOperation(index, nodes) {\n  return { type: \"insert\", index, nodes };\n}\nfunction removeOperation(indexes) {\n  return { type: \"remove\", indexes };\n}\nfunction replaceOperation() {\n  return { type: \"replace\" };\n}\nfunction splitIndexPath(indexPath) {\n  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];\n}\nfunction getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */ new Map()) {\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    switch (operations.get(parentKey)?.type) {\n      case \"remove\":\n        continue;\n    }\n    operations.set(parentKey, replaceOperation());\n  }\n  const operation = operations.get(parentIndexPath.join());\n  switch (operation?.type) {\n    case \"remove\":\n      operations.set(parentIndexPath.join(), {\n        type: \"removeThenInsert\",\n        removeIndexes: operation.indexes,\n        insertIndex: index,\n        insertNodes: nodes\n      });\n      break;\n    default:\n      operations.set(parentIndexPath.join(), insertOperation(index, nodes));\n  }\n  return operations;\n}\nfunction getRemovalOperations(indexPaths) {\n  const operations = /* @__PURE__ */ new Map();\n  const indexesToRemove = /* @__PURE__ */ new Map();\n  for (const indexPath of indexPaths) {\n    const parentKey = indexPath.slice(0, -1).join();\n    const value = indexesToRemove.get(parentKey) ?? [];\n    value.push(indexPath[indexPath.length - 1]);\n    indexesToRemove.set(\n      parentKey,\n      value.sort((a, b) => a - b)\n    );\n  }\n  for (const indexPath of indexPaths) {\n    for (let i = indexPath.length - 2; i >= 0; i--) {\n      const parentKey = indexPath.slice(0, i).join();\n      if (!operations.has(parentKey)) {\n        operations.set(parentKey, replaceOperation());\n      }\n    }\n  }\n  for (const [parentKey, indexes] of indexesToRemove) {\n    operations.set(parentKey, removeOperation(indexes));\n  }\n  return operations;\n}\nfunction getReplaceOperations(indexPath, node) {\n  const operations = /* @__PURE__ */ new Map();\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    operations.set(parentKey, replaceOperation());\n  }\n  operations.set(parentIndexPath.join(), {\n    type: \"removeThenInsert\",\n    removeIndexes: [index],\n    insertIndex: index,\n    insertNodes: [node]\n  });\n  return operations;\n}\nfunction mutate(node, operations, options) {\n  return map(node, {\n    ...options,\n    getChildren: (node2, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"replace\":\n        case \"remove\":\n        case \"removeThenInsert\":\n        case \"insert\":\n          return options.getChildren(node2, indexPath);\n        default:\n          return [];\n      }\n    },\n    transform: (node2, children, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"remove\":\n          return options.create(\n            node2,\n            children.filter((_, index) => !operation.indexes.includes(index)),\n            indexPath\n          );\n        case \"removeThenInsert\":\n          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));\n          const adjustedIndex = operation.removeIndexes.reduce(\n            (index, removedIndex) => removedIndex < index ? index - 1 : index,\n            operation.insertIndex\n          );\n          return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);\n        case \"insert\":\n          return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);\n        case \"replace\":\n          return options.create(node2, children, indexPath);\n        default:\n          return node2;\n      }\n    }\n  });\n}\nfunction splice(array, start, deleteCount, ...items) {\n  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];\n}\nfunction map(node, options) {\n  const childrenMap = {};\n  visit(node, {\n    ...options,\n    onLeave: (child, indexPath) => {\n      const keyIndexPath = [0, ...indexPath];\n      const key = keyIndexPath.join();\n      const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);\n      const parentKey = keyIndexPath.slice(0, -1).join();\n      const parentChildren = childrenMap[parentKey] ?? [];\n      parentChildren.push(transformed);\n      childrenMap[parentKey] = parentChildren;\n    }\n  });\n  return childrenMap[\"\"][0];\n}\nfunction insert2(node, options) {\n  const { nodes, at } = options;\n  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);\n  const state = getInsertionOperations(at, nodes);\n  return mutate(node, state, options);\n}\nfunction replace(node, options) {\n  if (options.at.length === 0) return options.node;\n  const operations = getReplaceOperations(options.at, options.node);\n  return mutate(node, operations, options);\n}\nfunction remove(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);\n  }\n  const operations = getRemovalOperations(options.indexPaths);\n  return mutate(node, operations, options);\n}\nfunction move2(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't move the root node`);\n  }\n  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);\n  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);\n  const nodesToInsert = _ancestorIndexPaths.map((indexPath) => access(node, indexPath, options));\n  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));\n  return mutate(node, operations, options);\n}\nfunction visit(node, options) {\n  const { onEnter, onLeave, getChildren } = options;\n  let indexPath = [];\n  let stack = [{ node }];\n  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();\n  while (stack.length > 0) {\n    let wrapper = stack[stack.length - 1];\n    if (wrapper.state === void 0) {\n      const enterResult = onEnter?.(wrapper.node, getIndexPath());\n      if (enterResult === \"stop\") return;\n      wrapper.state = enterResult === \"skip\" ? -1 : 0;\n    }\n    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());\n    wrapper.children || (wrapper.children = children);\n    if (wrapper.state !== -1) {\n      if (wrapper.state < children.length) {\n        let currentIndex = wrapper.state;\n        indexPath.push(currentIndex);\n        stack.push({ node: children[currentIndex] });\n        wrapper.state = currentIndex + 1;\n        continue;\n      }\n      const leaveResult = onLeave?.(wrapper.node, getIndexPath());\n      if (leaveResult === \"stop\") return;\n    }\n    indexPath.pop();\n    stack.pop();\n  }\n}\n\n// src/tree-collection.ts\nvar TreeCollection = class _TreeCollection {\n  constructor(options) {\n    this.options = options;\n    __publicField(this, \"rootNode\");\n    __publicField(this, \"isEqual\", (other) => {\n      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isEqual)(this.rootNode, other.rootNode);\n    });\n    __publicField(this, \"getNodeChildren\", (node) => {\n      return this.options.nodeToChildren?.(node) ?? fallbackMethods.nodeToChildren(node) ?? [];\n    });\n    __publicField(this, \"resolveIndexPath\", (valueOrIndexPath) => {\n      return typeof valueOrIndexPath === \"string\" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;\n    });\n    __publicField(this, \"resolveNode\", (valueOrIndexPath) => {\n      const indexPath = this.resolveIndexPath(valueOrIndexPath);\n      return indexPath ? this.at(indexPath) : void 0;\n    });\n    __publicField(this, \"getNodeChildrenCount\", (node) => {\n      return this.options.nodeToChildrenCount?.(node) ?? fallbackMethods.nodeToChildrenCount(node);\n    });\n    __publicField(this, \"getNodeValue\", (node) => {\n      return this.options.nodeToValue?.(node) ?? fallbackMethods.nodeToValue(node);\n    });\n    __publicField(this, \"getNodeDisabled\", (node) => {\n      return this.options.isNodeDisabled?.(node) ?? fallbackMethods.isNodeDisabled(node);\n    });\n    __publicField(this, \"stringify\", (value) => {\n      const node = this.findNode(value);\n      if (!node) return null;\n      return this.stringifyNode(node);\n    });\n    __publicField(this, \"stringifyNode\", (node) => {\n      return this.options.nodeToString?.(node) ?? fallbackMethods.nodeToString(node);\n    });\n    __publicField(this, \"getFirstNode\", (rootNode = this.rootNode) => {\n      let firstChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {\n            firstChild = node;\n            return \"stop\";\n          }\n        }\n      });\n      return firstChild;\n    });\n    __publicField(this, \"getLastNode\", (rootNode = this.rootNode, opts = {}) => {\n      let lastChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isSameNode(node, rootNode)) return;\n          if (opts.skip?.({ value: this.getNodeValue(node), node, indexPath })) return \"skip\";\n          if (indexPath.length > 0 && !this.getNodeDisabled(node)) {\n            lastChild = node;\n          }\n        }\n      });\n      return lastChild;\n    });\n    __publicField(this, \"at\", (indexPath) => {\n      return access(this.rootNode, indexPath, {\n        getChildren: this.getNodeChildren\n      });\n    });\n    __publicField(this, \"findNode\", (value, rootNode = this.rootNode) => {\n      return find(rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"findNodes\", (values, rootNode = this.rootNode) => {\n      const v = new Set(values.filter((v2) => v2 != null));\n      return findAll(rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => v.has(this.getNodeValue(node))\n      });\n    });\n    __publicField(this, \"sort\", (values) => {\n      return values.reduce((acc, value) => {\n        const indexPath = this.getIndexPath(value);\n        if (indexPath) acc.push({ value, indexPath });\n        return acc;\n      }, []).sort((a, b) => compareIndexPaths(a.indexPath, b.indexPath)).map(({ value }) => value);\n    });\n    __publicField(this, \"getIndexPath\", (value) => {\n      return findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"getValue\", (indexPath) => {\n      const node = this.at(indexPath);\n      return node ? this.getNodeValue(node) : void 0;\n    });\n    __publicField(this, \"getValuePath\", (indexPath) => {\n      if (!indexPath) return [];\n      const valuePath = [];\n      let currentPath = [...indexPath];\n      while (currentPath.length > 0) {\n        const node = this.at(currentPath);\n        if (node) valuePath.unshift(this.getNodeValue(node));\n        currentPath.pop();\n      }\n      return valuePath;\n    });\n    __publicField(this, \"getDepth\", (value) => {\n      const indexPath = findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => this.getNodeValue(node) === value\n      });\n      return indexPath?.length ?? 0;\n    });\n    __publicField(this, \"isSameNode\", (node, other) => {\n      return this.getNodeValue(node) === this.getNodeValue(other);\n    });\n    __publicField(this, \"isRootNode\", (node) => {\n      return this.isSameNode(node, this.rootNode);\n    });\n    __publicField(this, \"contains\", (parentIndexPath, valueIndexPath) => {\n      if (!parentIndexPath || !valueIndexPath) return false;\n      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);\n    });\n    __publicField(this, \"getNextNode\", (value, opts = {}) => {\n      let found = false;\n      let nextNode;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) {\n            if (nodeValue === value) {\n              found = true;\n            }\n            return \"skip\";\n          }\n          if (found && !this.getNodeDisabled(node)) {\n            nextNode = node;\n            return \"stop\";\n          }\n          if (nodeValue === value) {\n            found = true;\n          }\n        }\n      });\n      return nextNode;\n    });\n    __publicField(this, \"getPreviousNode\", (value, opts = {}) => {\n      let previousNode;\n      let found = false;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) {\n            return \"skip\";\n          }\n          if (nodeValue === value) {\n            found = true;\n            return \"stop\";\n          }\n          if (!this.getNodeDisabled(node)) {\n            previousNode = node;\n          }\n        }\n      });\n      return found ? previousNode : void 0;\n    });\n    __publicField(this, \"getParentNodes\", (valueOrIndexPath) => {\n      const indexPath = this.resolveIndexPath(valueOrIndexPath)?.slice();\n      if (!indexPath) return [];\n      const result = [];\n      while (indexPath.length > 0) {\n        indexPath.pop();\n        const parentNode = this.at(indexPath);\n        if (parentNode && !this.isRootNode(parentNode)) {\n          result.unshift(parentNode);\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"getDescendantNodes\", (valueOrIndexPath, options) => {\n      const parentNode = this.resolveNode(valueOrIndexPath);\n      if (!parentNode) return [];\n      const result = [];\n      visit(parentNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, nodeIndexPath) => {\n          if (nodeIndexPath.length === 0) return;\n          if (!options?.withBranch && this.isBranchNode(node)) return;\n          result.push(node);\n        }\n      });\n      return result;\n    });\n    __publicField(this, \"getDescendantValues\", (valueOrIndexPath, options) => {\n      const children = this.getDescendantNodes(valueOrIndexPath, options);\n      return children.map((child) => this.getNodeValue(child));\n    });\n    __publicField(this, \"getParentIndexPath\", (indexPath) => {\n      return indexPath.slice(0, -1);\n    });\n    __publicField(this, \"getParentNode\", (valueOrIndexPath) => {\n      const indexPath = this.resolveIndexPath(valueOrIndexPath);\n      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;\n    });\n    __publicField(this, \"visit\", (opts) => {\n      const { skip, ...rest } = opts;\n      visit(this.rootNode, {\n        ...rest,\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          if (skip?.({ value: this.getNodeValue(node), node, indexPath })) return \"skip\";\n          return rest.onEnter?.(node, indexPath);\n        }\n      });\n    });\n    __publicField(this, \"getPreviousSibling\", (indexPath) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = indexPath[indexPath.length - 1];\n      while (--idx >= 0) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getNextSibling\", (indexPath) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = indexPath[indexPath.length - 1];\n      while (++idx < siblings.length) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getSiblingNodes\", (indexPath) => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this.getNodeChildren(parentNode) : [];\n    });\n    __publicField(this, \"getValues\", (rootNode = this.rootNode) => {\n      const values = flatMap(rootNode, {\n        getChildren: this.getNodeChildren,\n        transform: (node) => [this.getNodeValue(node)]\n      });\n      return values.slice(1);\n    });\n    __publicField(this, \"isSameDepth\", (indexPath, depth) => {\n      if (depth == null) return true;\n      return indexPath.length === depth;\n    });\n    __publicField(this, \"isBranchNode\", (node) => {\n      return this.getNodeChildren(node).length > 0 || this.getNodeChildrenCount(node) != null;\n    });\n    __publicField(this, \"getBranchValues\", (rootNode = this.rootNode, opts = {}) => {\n      let values = [];\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (indexPath.length === 0) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) return \"skip\";\n          if (this.isBranchNode(node) && this.isSameDepth(indexPath, opts.depth)) {\n            values.push(this.getNodeValue(node));\n          }\n        }\n      });\n      return values;\n    });\n    __publicField(this, \"flatten\", (rootNode = this.rootNode) => {\n      return flatten(rootNode, { getChildren: this.getNodeChildren });\n    });\n    __publicField(this, \"_create\", (node, children) => {\n      return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.compact)({ ...node, children: children.length > 0 ? children : void 0 });\n    });\n    __publicField(this, \"_insert\", (rootNode, indexPath, nodes) => {\n      return this.copy(\n        insert2(rootNode, { at: indexPath, nodes, getChildren: this.getNodeChildren, create: this._create })\n      );\n    });\n    __publicField(this, \"copy\", (rootNode) => {\n      return new _TreeCollection({ ...this.options, rootNode });\n    });\n    __publicField(this, \"_replace\", (rootNode, indexPath, node) => {\n      return this.copy(\n        replace(rootNode, { at: indexPath, node, getChildren: this.getNodeChildren, create: this._create })\n      );\n    });\n    __publicField(this, \"_move\", (rootNode, indexPaths, to) => {\n      return this.copy(move2(rootNode, { indexPaths, to, getChildren: this.getNodeChildren, create: this._create }));\n    });\n    __publicField(this, \"_remove\", (rootNode, indexPaths) => {\n      return this.copy(remove(rootNode, { indexPaths, getChildren: this.getNodeChildren, create: this._create }));\n    });\n    __publicField(this, \"replace\", (indexPath, node) => {\n      return this._replace(this.rootNode, indexPath, node);\n    });\n    __publicField(this, \"remove\", (indexPaths) => {\n      return this._remove(this.rootNode, indexPaths);\n    });\n    __publicField(this, \"insertBefore\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;\n    });\n    __publicField(this, \"insertAfter\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const nextIndex2 = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];\n      return this._insert(this.rootNode, nextIndex2, nodes);\n    });\n    __publicField(this, \"move\", (fromIndexPaths, toIndexPath) => {\n      return this._move(this.rootNode, fromIndexPaths, toIndexPath);\n    });\n    __publicField(this, \"filter\", (predicate) => {\n      const filteredRoot = filter(this.rootNode, {\n        predicate,\n        getChildren: this.getNodeChildren,\n        create: this._create\n      });\n      return this.copy(filteredRoot);\n    });\n    __publicField(this, \"toJSON\", () => {\n      return this.getValues(this.rootNode);\n    });\n    this.rootNode = options.rootNode;\n  }\n};\nfunction flattenedToTree(nodes, options = fallbackMethods) {\n  if (nodes.length === 0) {\n    throw new Error(\"[zag-js/tree] Cannot create tree from empty flattened array\");\n  }\n  const rootFlatNode = nodes.find((node) => node._parent === void 0);\n  if (!rootFlatNode) {\n    throw new Error(\"[zag-js/tree] No root node found in flattened data\");\n  }\n  const nodeMap = /* @__PURE__ */ new Map();\n  nodes.forEach((node) => {\n    nodeMap.set(node._index, node);\n  });\n  const buildNode = (idx) => {\n    const flatNode = nodeMap.get(idx);\n    if (!flatNode) return {};\n    const { _children, _parent, _index, ...cleanNode } = flatNode;\n    const children = [];\n    _children?.forEach((childIndex) => {\n      children.push(buildNode(childIndex));\n    });\n    return {\n      ...cleanNode,\n      ...children.length > 0 && { children }\n    };\n  };\n  const rootNode = buildNode(rootFlatNode._index);\n  return new TreeCollection({ ...options, rootNode });\n}\nfunction filePathToTree(paths) {\n  const rootNode = {\n    label: \"\",\n    value: \"ROOT\",\n    children: []\n  };\n  paths.forEach((path) => {\n    const parts = path.split(\"/\");\n    let currentNode = rootNode;\n    parts.forEach((part, index) => {\n      let childNode = currentNode.children?.find((child) => child.label === part);\n      if (!childNode) {\n        childNode = {\n          value: parts.slice(0, index + 1).join(\"/\"),\n          label: part\n        };\n        currentNode.children || (currentNode.children = []);\n        currentNode.children.push(childNode);\n      }\n      currentNode = childNode;\n    });\n  });\n  return new TreeCollection({ rootNode });\n}\nvar fallbackMethods = {\n  nodeToValue(node) {\n    if (typeof node === \"string\") return node;\n    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(node) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(node, \"value\")) return node.value;\n    return \"\";\n  },\n  nodeToString(node) {\n    if (typeof node === \"string\") return node;\n    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(node) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(node, \"label\")) return node.label;\n    return fallbackMethods.nodeToValue(node);\n  },\n  isNodeDisabled(node) {\n    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(node) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(node, \"disabled\")) return !!node.disabled;\n    return false;\n  },\n  nodeToChildren(node) {\n    return node.children;\n  },\n  nodeToChildrenCount(node) {\n    if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(node) && (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.hasProp)(node, \"childrenCount\")) return node.childrenCount;\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHphZy1qcytjb2xsZWN0aW9uQDEuMTguMi9ub2RlX21vZHVsZXMvQHphZy1qcy9jb2xsZWN0aW9uL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFpRzs7QUFFakc7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBUSxVQUFVLHNEQUFPO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLHVEQUFRLFVBQVUsc0RBQU87QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQSxRQUFRLHVEQUFRLFVBQVUsc0RBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBa0Q7QUFDckYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBTztBQUNwQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBSztBQUNsQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDLHVCQUF1Qix3REFBUyx1QkFBdUIsTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQyx1QkFBdUIsd0RBQVMsdUJBQXVCLE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsc0RBQU87QUFDcEIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUNBQXFDO0FBQ3hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNEQUFPO0FBQ3BCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQWlEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQSxPQUFPLHlFQUF5RSxPQUFPO0FBQ3ZGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1DQUFtQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUNBQW1DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWlEO0FBQ3hFO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1DQUFtQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLGlDQUFpQyxtQ0FBbUM7QUFDcEUsS0FBSztBQUNMO0FBQ0EsYUFBYSxzREFBTyxHQUFHLDREQUE0RDtBQUNuRixLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QiwrRUFBK0U7QUFDM0c7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsMkJBQTJCO0FBQzlELEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLDhFQUE4RTtBQUMxRztBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5Qyx5RUFBeUU7QUFDbEgsS0FBSztBQUNMO0FBQ0EsMENBQTBDLHFFQUFxRTtBQUMvRyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBUSxVQUFVLHNEQUFPO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLHVEQUFRLFVBQVUsc0RBQU87QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQSxRQUFRLHVEQUFRLFVBQVUsc0RBQU87QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFFBQVEsdURBQVEsVUFBVSxzREFBTztBQUNqQztBQUNBOztBQUUwSSIsInNvdXJjZXMiOlsiL1VzZXJzL3BldGVyL0RvY3VtZW50cy9HaXRIdWIvY3JlYXRvci1jYXJkL25vZGVfbW9kdWxlcy8ucG5wbS9AemFnLWpzK2NvbGxlY3Rpb25AMS4xOC4yL25vZGVfbW9kdWxlcy9AemFnLWpzL2NvbGxlY3Rpb24vZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNPYmplY3QsIGhhc1Byb3AsIGlzRXF1YWwsIGNodW5rLCBwcmV2SW5kZXgsIG5leHRJbmRleCwgY29tcGFjdCB9IGZyb20gJ0B6YWctanMvdXRpbHMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xudmFyIGZhbGxiYWNrID0ge1xuICBpdGVtVG9WYWx1ZShpdGVtKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSByZXR1cm4gaXRlbTtcbiAgICBpZiAoaXNPYmplY3QoaXRlbSkgJiYgaGFzUHJvcChpdGVtLCBcInZhbHVlXCIpKSByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSxcbiAgaXRlbVRvU3RyaW5nKGl0ZW0pIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHJldHVybiBpdGVtO1xuICAgIGlmIChpc09iamVjdChpdGVtKSAmJiBoYXNQcm9wKGl0ZW0sIFwibGFiZWxcIikpIHJldHVybiBpdGVtLmxhYmVsO1xuICAgIHJldHVybiBmYWxsYmFjay5pdGVtVG9WYWx1ZShpdGVtKTtcbiAgfSxcbiAgaXNJdGVtRGlzYWJsZWQoaXRlbSkge1xuICAgIGlmIChpc09iamVjdChpdGVtKSAmJiBoYXNQcm9wKGl0ZW0sIFwiZGlzYWJsZWRcIikpIHJldHVybiAhIWl0ZW0uZGlzYWJsZWQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIExpc3RDb2xsZWN0aW9uID0gY2xhc3MgX0xpc3RDb2xsZWN0aW9uIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIml0ZW1zXCIpO1xuICAgIC8qKlxuICAgICAqIENvcHkgdGhlIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29weVwiLCAoaXRlbXMpID0+IHtcbiAgICAgIHJldHVybiBuZXcgX0xpc3RDb2xsZWN0aW9uKHsgLi4udGhpcy5vcHRpb25zLCBpdGVtczogaXRlbXMgPz8gWy4uLnRoaXMuaXRlbXNdIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVxdWFsIHRvIGFub3RoZXIgY29sbGVjdGlvblxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc0VxdWFsXCIsIChvdGhlcikgPT4ge1xuICAgICAgcmV0dXJuIGlzRXF1YWwodGhpcy5pdGVtcywgb3RoZXIuaXRlbXMpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgY29sbGVjdGlvbiBpdGVtc1xuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRJdGVtc1wiLCAoaXRlbXMpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcHkoaXRlbXMpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSB2YWx1ZXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0VmFsdWVzXCIsIChpdGVtcyA9IHRoaXMuaXRlbXMpID0+IHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1zKS5tYXAoKGl0ZW0pID0+IHRoaXMuZ2V0SXRlbVZhbHVlKGl0ZW0pKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpdGVtIGJhc2VkIG9uIGl0cyB2YWx1ZVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaW5kXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4T2YodmFsdWUpO1xuICAgICAgcmV0dXJuIGluZGV4ICE9IG51bGwgPyB0aGlzLmF0KGluZGV4KSA6IG51bGw7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpdGVtcyBiYXNlZCBvbiBpdHMgdmFsdWVzXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpbmRNYW55XCIsICh2YWx1ZXMpID0+IHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlcykubWFwKCh2YWx1ZSkgPT4gdGhpcy5maW5kKHZhbHVlKSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtICE9IG51bGwpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaXRlbSBiYXNlZCBvbiBpdHMgaW5kZXhcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXRcIiwgKGluZGV4KSA9PiB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5ncm91cEJ5ICYmICF0aGlzLm9wdGlvbnMuZ3JvdXBTb3J0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zW2luZGV4XSA/PyBudWxsO1xuICAgICAgfVxuICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICBjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwKCk7XG4gICAgICBmb3IgKGNvbnN0IFssIGl0ZW1zXSBvZiBncm91cHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgaWYgKGlkeCA9PT0gaW5kZXgpIHJldHVybiBpdGVtO1xuICAgICAgICAgIGlkeCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic29ydEZuXCIsICh2YWx1ZUEsIHZhbHVlQikgPT4ge1xuICAgICAgY29uc3QgaW5kZXhBID0gdGhpcy5pbmRleE9mKHZhbHVlQSk7XG4gICAgICBjb25zdCBpbmRleEIgPSB0aGlzLmluZGV4T2YodmFsdWVCKTtcbiAgICAgIHJldHVybiAoaW5kZXhBID8/IDApIC0gKGluZGV4QiA/PyAwKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTb3J0IHRoZSB2YWx1ZXMgYmFzZWQgb24gdGhlaXIgaW5kZXhcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic29ydFwiLCAodmFsdWVzKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLnZhbHVlc10uc29ydCh0aGlzLnNvcnRGbi5iaW5kKHRoaXMpKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGl0ZW0gdG8gYSB2YWx1ZVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRJdGVtVmFsdWVcIiwgKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pdGVtVG9WYWx1ZT8uKGl0ZW0pID8/IGZhbGxiYWNrLml0ZW1Ub1ZhbHVlKGl0ZW0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYW4gaXRlbSBpcyBkaXNhYmxlZFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRJdGVtRGlzYWJsZWRcIiwgKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaXNJdGVtRGlzYWJsZWQ/LihpdGVtKSA/PyBmYWxsYmFjay5pc0l0ZW1EaXNhYmxlZChpdGVtKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGl0ZW0gdG8gYSBzdHJpbmdcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RyaW5naWZ5SXRlbVwiLCAoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLml0ZW1Ub1N0cmluZz8uKGl0ZW0pID8/IGZhbGxiYWNrLml0ZW1Ub1N0cmluZyhpdGVtKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmdcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RyaW5naWZ5XCIsICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5SXRlbSh0aGlzLmZpbmQodmFsdWUpKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGFycmF5IG9mIGl0ZW1zIHRvIGEgc3RyaW5nXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0cmluZ2lmeUl0ZW1zXCIsIChpdGVtcywgc2VwYXJhdG9yID0gXCIsIFwiKSA9PiB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVtcykubWFwKChpdGVtKSA9PiB0aGlzLnN0cmluZ2lmeUl0ZW0oaXRlbSkpLmZpbHRlcihCb29sZWFuKS5qb2luKHNlcGFyYXRvcik7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiBhcnJheSBvZiBpdGVtcyB0byBhIHN0cmluZ1xuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHJpbmdpZnlNYW55XCIsICh2YWx1ZSwgc2VwYXJhdG9yKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnlJdGVtcyh0aGlzLmZpbmRNYW55KHZhbHVlKSwgc2VwYXJhdG9yKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjb2xsZWN0aW9uIGhhcyBhIHZhbHVlXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhc1wiLCAodmFsdWUpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjb2xsZWN0aW9uIGhhcyBhbiBpdGVtXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhc0l0ZW1cIiwgKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLmhhcyh0aGlzLmdldEl0ZW1WYWx1ZShpdGVtKSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR3JvdXAgaXRlbXMgYnkgdGhlIGdyb3VwQnkgZnVuY3Rpb24gcHJvdmlkZWQgaW4gb3B0aW9uc1xuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgW2dyb3VwS2V5LCBpdGVtc10gdHVwbGVzXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdyb3VwXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZ3JvdXBCeSwgZ3JvdXBTb3J0IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoIWdyb3VwQnkpIHJldHVybiBbW1wiXCIsIFsuLi50aGlzLml0ZW1zXV1dO1xuICAgICAgY29uc3QgZ3JvdXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZ3JvdXBLZXkgPSBncm91cEJ5KGl0ZW0sIGluZGV4KTtcbiAgICAgICAgaWYgKCFncm91cHMuaGFzKGdyb3VwS2V5KSkge1xuICAgICAgICAgIGdyb3Vwcy5zZXQoZ3JvdXBLZXksIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBncm91cHMuZ2V0KGdyb3VwS2V5KS5wdXNoKGl0ZW0pO1xuICAgICAgfSk7XG4gICAgICBsZXQgZW50cmllcyA9IEFycmF5LmZyb20oZ3JvdXBzLmVudHJpZXMoKSk7XG4gICAgICBpZiAoZ3JvdXBTb3J0KSB7XG4gICAgICAgIGVudHJpZXMuc29ydCgoW2FdLCBbYl0pID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGdyb3VwU29ydCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZ3JvdXBTb3J0KGEsIGIpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyb3VwU29ydCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4QSA9IGdyb3VwU29ydC5pbmRleE9mKGEpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXhCID0gZ3JvdXBTb3J0LmluZGV4T2YoYik7XG4gICAgICAgICAgICBpZiAoaW5kZXhBID09PSAtMSkgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoaW5kZXhCID09PSAtMSkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4QSAtIGluZGV4QjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdyb3VwU29ydCA9PT0gXCJhc2NcIikgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbiAgICAgICAgICBpZiAoZ3JvdXBTb3J0ID09PSBcImRlc2NcIikgcmV0dXJuIGIubG9jYWxlQ29tcGFyZShhKTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cmllcztcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldE5leHRWYWx1ZVwiLCAodmFsdWUsIHN0ZXAgPSAxLCBjbGFtcCA9IGZhbHNlKSA9PiB7XG4gICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIG51bGw7XG4gICAgICBpbmRleCA9IGNsYW1wID8gTWF0aC5taW4oaW5kZXggKyBzdGVwLCB0aGlzLnNpemUgLSAxKSA6IGluZGV4ICsgc3RlcDtcbiAgICAgIHdoaWxlIChpbmRleCA8PSB0aGlzLnNpemUgJiYgdGhpcy5nZXRJdGVtRGlzYWJsZWQodGhpcy5hdChpbmRleCkpKSBpbmRleCsrO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbVZhbHVlKHRoaXMuYXQoaW5kZXgpKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyB2YWx1ZSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRQcmV2aW91c1ZhbHVlXCIsICh2YWx1ZSwgc3RlcCA9IDEsIGNsYW1wID0gZmFsc2UpID0+IHtcbiAgICAgIGxldCBpbmRleCA9IHRoaXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gbnVsbDtcbiAgICAgIGluZGV4ID0gY2xhbXAgPyBNYXRoLm1heChpbmRleCAtIHN0ZXAsIDApIDogaW5kZXggLSBzdGVwO1xuICAgICAgd2hpbGUgKGluZGV4ID49IDAgJiYgdGhpcy5nZXRJdGVtRGlzYWJsZWQodGhpcy5hdChpbmRleCkpKSBpbmRleC0tO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbVZhbHVlKHRoaXMuYXQoaW5kZXgpKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGluZGV4IG9mIGFuIGl0ZW0gYmFzZWQgb24gaXRzIGtleVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmRleE9mXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiAtMTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmdyb3VwQnkgJiYgIXRoaXMub3B0aW9ucy5ncm91cFNvcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmluZEluZGV4KChpdGVtKSA9PiB0aGlzLmdldEl0ZW1WYWx1ZShpdGVtKSA9PT0gdmFsdWUpO1xuICAgICAgfVxuICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICBjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwKCk7XG4gICAgICBmb3IgKGNvbnN0IFssIGl0ZW1zXSBvZiBncm91cHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0SXRlbVZhbHVlKGl0ZW0pID09PSB2YWx1ZSkgcmV0dXJuIGlkeDtcbiAgICAgICAgICBpZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRCeVRleHRcIiwgKHRleHQsIGN1cnJlbnQpID0+IHtcbiAgICAgIGxldCBpdGVtcyA9IGN1cnJlbnQgIT0gbnVsbCA/IHdyYXAodGhpcy5pdGVtcywgdGhpcy5pbmRleE9mKGN1cnJlbnQpKSA6IHRoaXMuaXRlbXM7XG4gICAgICBjb25zdCBpc1NpbmdsZUtleSA9IHRleHQubGVuZ3RoID09PSAxO1xuICAgICAgaWYgKGlzU2luZ2xlS2V5KSBpdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gdGhpcy5nZXRJdGVtVmFsdWUoaXRlbSkgIT09IGN1cnJlbnQpO1xuICAgICAgcmV0dXJuIGl0ZW1zLmZpbmQoKGl0ZW0pID0+IG1hdGNoKHRoaXMuc3RyaW5naWZ5SXRlbShpdGVtKSwgdGV4dCkpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgYSB2YWx1ZSBiYXNlZCBvbiBhIHF1ZXJ5XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNlYXJjaFwiLCAocXVlcnlTdHJpbmcsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RhdGUsIGN1cnJlbnRWYWx1ZSwgdGltZW91dCA9IDM1MCB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHNlYXJjaCA9IHN0YXRlLmtleXNTb0ZhciArIHF1ZXJ5U3RyaW5nO1xuICAgICAgY29uc3QgaXNSZXBlYXRlZCA9IHNlYXJjaC5sZW5ndGggPiAxICYmIEFycmF5LmZyb20oc2VhcmNoKS5ldmVyeSgoY2hhcikgPT4gY2hhciA9PT0gc2VhcmNoWzBdKTtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gaXNSZXBlYXRlZCA/IHNlYXJjaFswXSA6IHNlYXJjaDtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldEJ5VGV4dChxdWVyeSwgY3VycmVudFZhbHVlKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRJdGVtVmFsdWUoaXRlbSk7XG4gICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZXIpO1xuICAgICAgICBzdGF0ZS50aW1lciA9IC0xO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlKHZhbHVlMikge1xuICAgICAgICBzdGF0ZS5rZXlzU29GYXIgPSB2YWx1ZTI7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgaWYgKHZhbHVlMiAhPT0gXCJcIikge1xuICAgICAgICAgIHN0YXRlLnRpbWVyID0gK3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlKFwiXCIpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGUoc2VhcmNoKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gaXRlbSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1cGRhdGVcIiwgKHZhbHVlLCBpdGVtKSA9PiB7XG4gICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KFsuLi50aGlzLml0ZW1zLnNsaWNlKDAsIGluZGV4KSwgaXRlbSwgLi4udGhpcy5pdGVtcy5zbGljZShpbmRleCArIDEpXSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24gaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgYXBwZW5kIGl0XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVwc2VydFwiLCAodmFsdWUsIGl0ZW0sIG1vZGUgPSBcImFwcGVuZFwiKSA9PiB7XG4gICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBjb25zdCBmbiA9IG1vZGUgPT09IFwiYXBwZW5kXCIgPyB0aGlzLmFwcGVuZCA6IHRoaXMucHJlcGVuZDtcbiAgICAgICAgcmV0dXJuIGZuKGl0ZW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29weShbLi4udGhpcy5pdGVtcy5zbGljZSgwLCBpbmRleCksIGl0ZW0sIC4uLnRoaXMuaXRlbXMuc2xpY2UoaW5kZXggKyAxKV0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEluc2VydCBpdGVtcyBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluc2VydFwiLCAoaW5kZXgsIC4uLml0ZW1zKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KGluc2VydCh0aGlzLml0ZW1zLCBpbmRleCwgLi4uaXRlbXMpKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgaXRlbXMgYmVmb3JlIGEgc3BlY2lmaWMgdmFsdWVcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5zZXJ0QmVmb3JlXCIsICh2YWx1ZSwgLi4uaXRlbXMpID0+IHtcbiAgICAgIGxldCB0b0luZGV4ID0gdGhpcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgIGlmICh0b0luZGV4ID09PSAtMSkge1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDApIHRvSW5kZXggPSAwO1xuICAgICAgICBlbHNlIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29weShpbnNlcnQodGhpcy5pdGVtcywgdG9JbmRleCwgLi4uaXRlbXMpKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgaXRlbXMgYWZ0ZXIgYSBzcGVjaWZpYyB2YWx1ZVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbnNlcnRBZnRlclwiLCAodmFsdWUsIC4uLml0ZW1zKSA9PiB7XG4gICAgICBsZXQgdG9JbmRleCA9IHRoaXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICBpZiAodG9JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKSB0b0luZGV4ID0gMDtcbiAgICAgICAgZWxzZSByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvcHkoaW5zZXJ0KHRoaXMuaXRlbXMsIHRvSW5kZXggKyAxLCAuLi5pdGVtcykpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFByZXBlbmQgaXRlbXMgdG8gdGhlIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJlcGVuZFwiLCAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcHkoaW5zZXJ0KHRoaXMuaXRlbXMsIDAsIC4uLml0ZW1zKSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQXBwZW5kIGl0ZW1zIHRvIHRoZSBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFwcGVuZFwiLCAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcHkoaW5zZXJ0KHRoaXMuaXRlbXMsIHRoaXMuaXRlbXMubGVuZ3RoLCAuLi5pdGVtcykpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZpbHRlciB0aGUgY29sbGVjdGlvblxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWx0ZXJcIiwgKGZuKSA9PiB7XG4gICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gdGhpcy5pdGVtcy5maWx0ZXIoKGl0ZW0sIGluZGV4KSA9PiBmbih0aGlzLnN0cmluZ2lmeUl0ZW0oaXRlbSksIGluZGV4LCBpdGVtKSk7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KGZpbHRlcmVkSXRlbXMpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBpdGVtcyBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbW92ZVwiLCAoLi4uaXRlbXNPclZhbHVlcykgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gaXRlbXNPclZhbHVlcy5tYXAoXG4gICAgICAgIChpdGVtT3JWYWx1ZSkgPT4gdHlwZW9mIGl0ZW1PclZhbHVlID09PSBcInN0cmluZ1wiID8gaXRlbU9yVmFsdWUgOiB0aGlzLmdldEl0ZW1WYWx1ZShpdGVtT3JWYWx1ZSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KFxuICAgICAgICB0aGlzLml0ZW1zLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRJdGVtVmFsdWUoaXRlbSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gIXZhbHVlcy5pbmNsdWRlcyh2YWx1ZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE1vdmUgYW4gaXRlbSB0byBhIHNwZWNpZmljIGluZGV4XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1vdmVcIiwgKHZhbHVlLCB0b0luZGV4KSA9PiB7XG4gICAgICBjb25zdCBmcm9tSW5kZXggPSB0aGlzLmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuY29weShtb3ZlKHRoaXMuaXRlbXMsIFtmcm9tSW5kZXhdLCB0b0luZGV4KSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTW92ZSBpdGVtcyBiZWZvcmUgYSBzcGVjaWZpYyB2YWx1ZVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb3ZlQmVmb3JlXCIsICh2YWx1ZSwgLi4udmFsdWVzKSA9PiB7XG4gICAgICBsZXQgdG9JbmRleCA9IHRoaXMuaXRlbXMuZmluZEluZGV4KChpdGVtKSA9PiB0aGlzLmdldEl0ZW1WYWx1ZShpdGVtKSA9PT0gdmFsdWUpO1xuICAgICAgaWYgKHRvSW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgICAgIGxldCBpbmRpY2VzID0gdmFsdWVzLm1hcCgodmFsdWUyKSA9PiB0aGlzLml0ZW1zLmZpbmRJbmRleCgoaXRlbSkgPT4gdGhpcy5nZXRJdGVtVmFsdWUoaXRlbSkgPT09IHZhbHVlMikpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgIHJldHVybiB0aGlzLmNvcHkobW92ZSh0aGlzLml0ZW1zLCBpbmRpY2VzLCB0b0luZGV4KSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTW92ZSBpdGVtcyBhZnRlciBhIHNwZWNpZmljIHZhbHVlXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1vdmVBZnRlclwiLCAodmFsdWUsIC4uLnZhbHVlcykgPT4ge1xuICAgICAgbGV0IHRvSW5kZXggPSB0aGlzLml0ZW1zLmZpbmRJbmRleCgoaXRlbSkgPT4gdGhpcy5nZXRJdGVtVmFsdWUoaXRlbSkgPT09IHZhbHVlKTtcbiAgICAgIGlmICh0b0luZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gICAgICBsZXQgaW5kaWNlcyA9IHZhbHVlcy5tYXAoKHZhbHVlMikgPT4gdGhpcy5pdGVtcy5maW5kSW5kZXgoKGl0ZW0pID0+IHRoaXMuZ2V0SXRlbVZhbHVlKGl0ZW0pID09PSB2YWx1ZTIpKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KG1vdmUodGhpcy5pdGVtcywgaW5kaWNlcywgdG9JbmRleCArIDEpKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGl0ZW1zXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlb3JkZXJcIiwgKGZyb21JbmRleCwgdG9JbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY29weShtb3ZlKHRoaXMuaXRlbXMsIFtmcm9tSW5kZXhdLCB0b0luZGV4KSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gdmFsdWVzXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbXBhcmVWYWx1ZVwiLCAoYSwgYikgPT4ge1xuICAgICAgY29uc3QgaW5kZXhBID0gdGhpcy5pbmRleE9mKGEpO1xuICAgICAgY29uc3QgaW5kZXhCID0gdGhpcy5pbmRleE9mKGIpO1xuICAgICAgaWYgKGluZGV4QSA8IGluZGV4QikgcmV0dXJuIC0xO1xuICAgICAgaWYgKGluZGV4QSA+IGluZGV4QikgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJhbmdlIG9mIHZhbHVlcyBiZXR3ZWVuIHR3byB2YWx1ZXNcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmFuZ2VcIiwgKGZyb20sIHRvKSA9PiB7XG4gICAgICBsZXQga2V5cyA9IFtdO1xuICAgICAgbGV0IGtleSA9IGZyb207XG4gICAgICB3aGlsZSAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmZpbmQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0pIGtleXMucHVzaChrZXkpO1xuICAgICAgICBpZiAoa2V5ID09PSB0bykgcmV0dXJuIGtleXM7XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0TmV4dFZhbHVlKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByYW5nZSBvZiB2YWx1ZXMgYmV0d2VlbiB0d28gdmFsdWVzXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFZhbHVlUmFuZ2VcIiwgKGZyb20sIHRvKSA9PiB7XG4gICAgICBpZiAoZnJvbSAmJiB0bykge1xuICAgICAgICBpZiAodGhpcy5jb21wYXJlVmFsdWUoZnJvbSwgdG8pIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UodG8sIGZyb20pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNvbGxlY3Rpb24gdG8gYSBzdHJpbmdcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidG9TdHJpbmdcIiwgKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0SXRlbVZhbHVlKGl0ZW0pO1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuc3RyaW5naWZ5SXRlbShpdGVtKTtcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmdldEl0ZW1EaXNhYmxlZChpdGVtKTtcbiAgICAgICAgY29uc3QgaXRlbVN0cmluZyA9IFt2YWx1ZSwgbGFiZWwsIGRpc2FibGVkXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIjpcIik7XG4gICAgICAgIHJlc3VsdCArPSBpdGVtU3RyaW5nICsgXCIsXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNvbGxlY3Rpb24gdG8gYSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0b0pTT05cIiwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgICBmaXJzdDogdGhpcy5maXJzdFZhbHVlLFxuICAgICAgICBsYXN0OiB0aGlzLmxhc3RWYWx1ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLml0ZW1zID0gWy4uLm9wdGlvbnMuaXRlbXNdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldCBmaXJzdFZhbHVlKCkge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgd2hpbGUgKHRoaXMuZ2V0SXRlbURpc2FibGVkKHRoaXMuYXQoaW5kZXgpKSkgaW5kZXgrKztcbiAgICByZXR1cm4gdGhpcy5nZXRJdGVtVmFsdWUodGhpcy5hdChpbmRleCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uXG4gICAqL1xuICBnZXQgbGFzdFZhbHVlKCkge1xuICAgIGxldCBpbmRleCA9IHRoaXMuc2l6ZSAtIDE7XG4gICAgd2hpbGUgKHRoaXMuZ2V0SXRlbURpc2FibGVkKHRoaXMuYXQoaW5kZXgpKSkgaW5kZXgtLTtcbiAgICByZXR1cm4gdGhpcy5nZXRJdGVtVmFsdWUodGhpcy5hdChpbmRleCkpO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICB5aWVsZCogdGhpcy5pdGVtcztcbiAgfVxufTtcbnZhciBtYXRjaCA9IChsYWJlbCwgcXVlcnkpID0+IHtcbiAgcmV0dXJuICEhbGFiZWw/LnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChxdWVyeS50b0xvd2VyQ2FzZSgpKTtcbn07XG52YXIgd3JhcCA9ICh2LCBpZHgpID0+IHtcbiAgcmV0dXJuIHYubWFwKChfLCBpbmRleCkgPT4gdlsoTWF0aC5tYXgoaWR4LCAwKSArIGluZGV4KSAlIHYubGVuZ3RoXSk7XG59O1xuZnVuY3Rpb24gaXNMaXN0Q29sbGVjdGlvbih2KSB7XG4gIHJldHVybiB2IGluc3RhbmNlb2YgTGlzdENvbGxlY3Rpb247XG59XG5mdW5jdGlvbiBpbnNlcnQoaXRlbXMsIGluZGV4LCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIFsuLi5pdGVtcy5zbGljZSgwLCBpbmRleCksIC4uLnZhbHVlcywgLi4uaXRlbXMuc2xpY2UoaW5kZXgpXTtcbn1cbmZ1bmN0aW9uIG1vdmUoaXRlbXMsIGluZGljZXMsIHRvSW5kZXgpIHtcbiAgaW5kaWNlcyA9IFsuLi5pbmRpY2VzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGNvbnN0IGl0ZW1zVG9Nb3ZlID0gaW5kaWNlcy5tYXAoKGkpID0+IGl0ZW1zW2ldKTtcbiAgZm9yIChsZXQgaSA9IGluZGljZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpdGVtcyA9IFsuLi5pdGVtcy5zbGljZSgwLCBpbmRpY2VzW2ldKSwgLi4uaXRlbXMuc2xpY2UoaW5kaWNlc1tpXSArIDEpXTtcbiAgfVxuICB0b0luZGV4ID0gTWF0aC5tYXgoMCwgdG9JbmRleCAtIGluZGljZXMuZmlsdGVyKChpKSA9PiBpIDwgdG9JbmRleCkubGVuZ3RoKTtcbiAgcmV0dXJuIFsuLi5pdGVtcy5zbGljZSgwLCB0b0luZGV4KSwgLi4uaXRlbXNUb01vdmUsIC4uLml0ZW1zLnNsaWNlKHRvSW5kZXgpXTtcbn1cblxuLy8gc3JjL2dyaWQtY29sbGVjdGlvbi50c1xudmFyIEdyaWRDb2xsZWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBMaXN0Q29sbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNvbHVtbkNvdW50IH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb2x1bW5Db3VudFwiKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByb3cgZGF0YSBpbiB0aGUgZ3JpZFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRSb3dzXCIsICgpID0+IHtcbiAgICAgIHJldHVybiBjaHVuayhbLi4udGhpcy5pdGVtc10sIHRoaXMuY29sdW1uQ291bnQpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBncmlkXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFJvd0NvdW50XCIsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJvd3MoKS5sZW5ndGg7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtbiBpbiB0aGUgZ3JpZFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRDZWxsSW5kZXhcIiwgKHJvdywgY29sdW1uKSA9PiB7XG4gICAgICByZXR1cm4gcm93ICogdGhpcy5jb2x1bW5Db3VudCArIGNvbHVtbjtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW4gaW4gdGhlIGdyaWRcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0Q2VsbFwiLCAocm93LCBjb2x1bW4pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmF0KHRoaXMuZ2V0Q2VsbEluZGV4KHJvdywgY29sdW1uKSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm93IGFuZCBjb2x1bW4gaW5kZXggZm9yIGEgZ2l2ZW4gdmFsdWVcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0VmFsdWVDZWxsXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5jb2x1bW5Db3VudCk7XG4gICAgICBjb25zdCBjb2x1bW4gPSBpbmRleCAlIHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICByZXR1cm4geyByb3csIGNvbHVtbiB9O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IGVuYWJsZWQgY29sdW1uIGluIGEgcm93XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldExhc3RFbmFibGVkQ29sdW1uSW5kZXhcIiwgKHJvdykgPT4ge1xuICAgICAgZm9yIChsZXQgY29sID0gdGhpcy5jb2x1bW5Db3VudCAtIDE7IGNvbCA+PSAwOyBjb2wtLSkge1xuICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5nZXRDZWxsKHJvdywgY29sKTtcbiAgICAgICAgaWYgKGNlbGwgJiYgIXRoaXMuZ2V0SXRlbURpc2FibGVkKGNlbGwpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVuYWJsZWQgY29sdW1uIGluIGEgcm93XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldEZpcnN0RW5hYmxlZENvbHVtbkluZGV4XCIsIChyb3cpID0+IHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sdW1uQ291bnQ7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldENlbGwocm93LCBjb2wpO1xuICAgICAgICBpZiAoY2VsbCAmJiAhdGhpcy5nZXRJdGVtRGlzYWJsZWQoY2VsbCkpIHtcbiAgICAgICAgICByZXR1cm4gY29sO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgcm93IGluIHRoZSBncmlkLCBiYXNlZCBvbiB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRQcmV2aW91c1Jvd1ZhbHVlXCIsICh2YWx1ZSwgbG9vcCA9IGZhbHNlKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IHRoaXMuZ2V0VmFsdWVDZWxsKHZhbHVlKTtcbiAgICAgIGlmIChjdXJyZW50Q2VsbCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCByb3dzID0gdGhpcy5nZXRSb3dzKCk7XG4gICAgICBjb25zdCByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgIGxldCBwcmV2Um93SW5kZXggPSBjdXJyZW50Q2VsbC5yb3c7XG4gICAgICBsZXQgcHJldkNvbHVtbkluZGV4ID0gY3VycmVudENlbGwuY29sdW1uO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcm93Q291bnQ7IGkrKykge1xuICAgICAgICBwcmV2Um93SW5kZXggPSBwcmV2SW5kZXgocm93cywgcHJldlJvd0luZGV4LCB7IGxvb3AgfSk7XG4gICAgICAgIGNvbnN0IHByZXZSb3cgPSByb3dzW3ByZXZSb3dJbmRleF07XG4gICAgICAgIGlmICghcHJldlJvdykgY29udGludWU7XG4gICAgICAgIGNvbnN0IHByZXZDZWxsID0gcHJldlJvd1twcmV2Q29sdW1uSW5kZXhdO1xuICAgICAgICBpZiAoIXByZXZDZWxsKSB7XG4gICAgICAgICAgY29uc3QgbGFzdENvbHVtbkluZGV4ID0gdGhpcy5nZXRMYXN0RW5hYmxlZENvbHVtbkluZGV4KHByZXZSb3dJbmRleCk7XG4gICAgICAgICAgaWYgKGxhc3RDb2x1bW5JbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2Q29sdW1uSW5kZXggPSBsYXN0Q29sdW1uSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldENlbGwocHJldlJvd0luZGV4LCBwcmV2Q29sdW1uSW5kZXgpO1xuICAgICAgICBpZiAoIXRoaXMuZ2V0SXRlbURpc2FibGVkKGNlbGwpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbVZhbHVlKGNlbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maXJzdFZhbHVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHJvdyBpbiB0aGUgZ3JpZCwgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0TmV4dFJvd1ZhbHVlXCIsICh2YWx1ZSwgbG9vcCA9IGZhbHNlKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IHRoaXMuZ2V0VmFsdWVDZWxsKHZhbHVlKTtcbiAgICAgIGlmIChjdXJyZW50Q2VsbCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCByb3dzID0gdGhpcy5nZXRSb3dzKCk7XG4gICAgICBjb25zdCByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgIGxldCBuZXh0Um93SW5kZXggPSBjdXJyZW50Q2VsbC5yb3c7XG4gICAgICBsZXQgbmV4dENvbHVtbkluZGV4ID0gY3VycmVudENlbGwuY29sdW1uO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcm93Q291bnQ7IGkrKykge1xuICAgICAgICBuZXh0Um93SW5kZXggPSBuZXh0SW5kZXgocm93cywgbmV4dFJvd0luZGV4LCB7IGxvb3AgfSk7XG4gICAgICAgIGNvbnN0IG5leHRSb3cgPSByb3dzW25leHRSb3dJbmRleF07XG4gICAgICAgIGlmICghbmV4dFJvdykgY29udGludWU7XG4gICAgICAgIGNvbnN0IG5leHRDZWxsID0gbmV4dFJvd1tuZXh0Q29sdW1uSW5kZXhdO1xuICAgICAgICBpZiAoIW5leHRDZWxsKSB7XG4gICAgICAgICAgY29uc3QgbGFzdENvbHVtbkluZGV4ID0gdGhpcy5nZXRMYXN0RW5hYmxlZENvbHVtbkluZGV4KG5leHRSb3dJbmRleCk7XG4gICAgICAgICAgaWYgKGxhc3RDb2x1bW5JbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXh0Q29sdW1uSW5kZXggPSBsYXN0Q29sdW1uSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldENlbGwobmV4dFJvd0luZGV4LCBuZXh0Q29sdW1uSW5kZXgpO1xuICAgICAgICBpZiAoIXRoaXMuZ2V0SXRlbURpc2FibGVkKGNlbGwpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbVZhbHVlKGNlbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sYXN0VmFsdWU7XG4gICAgfSk7XG4gICAgdGhpcy5jb2x1bW5Db3VudCA9IGNvbHVtbkNvdW50O1xuICB9XG59O1xuZnVuY3Rpb24gaXNHcmlkQ29sbGVjdGlvbih2KSB7XG4gIHJldHVybiB2IGluc3RhbmNlb2YgR3JpZENvbGxlY3Rpb247XG59XG52YXIgU2VsZWN0aW9uID0gY2xhc3MgX1NlbGVjdGlvbiBleHRlbmRzIFNldCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlcyA9IFtdKSB7XG4gICAgc3VwZXIodmFsdWVzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2VsZWN0aW9uTW9kZVwiLCBcInNpbmdsZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGVzZWxlY3RhYmxlXCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb3B5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGNsb25lID0gbmV3IF9TZWxlY3Rpb24oWy4uLnRoaXNdKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoY2xvbmUpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzeW5jXCIsIChvdGhlcikgPT4ge1xuICAgICAgb3RoZXIuc2VsZWN0aW9uTW9kZSA9IHRoaXMuc2VsZWN0aW9uTW9kZTtcbiAgICAgIG90aGVyLmRlc2VsZWN0YWJsZSA9IHRoaXMuZGVzZWxlY3RhYmxlO1xuICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc0VtcHR5XCIsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IDA7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzU2VsZWN0ZWRcIiwgKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmhhcyh2YWx1ZSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNhblNlbGVjdFwiLCAoY29sbGVjdGlvbiwgdmFsdWUpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGUgIT09IFwibm9uZVwiIHx8ICFjb2xsZWN0aW9uLmdldEl0ZW1EaXNhYmxlZChjb2xsZWN0aW9uLmZpbmQodmFsdWUpKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmlyc3RTZWxlY3RlZFZhbHVlXCIsIChjb2xsZWN0aW9uKSA9PiB7XG4gICAgICBsZXQgZmlyc3RWYWx1ZSA9IG51bGw7XG4gICAgICBmb3IgKGxldCB2YWx1ZSBvZiB0aGlzKSB7XG4gICAgICAgIGlmICghZmlyc3RWYWx1ZSB8fCBjb2xsZWN0aW9uLmNvbXBhcmVWYWx1ZSh2YWx1ZSwgZmlyc3RWYWx1ZSkgPCAwKSB7XG4gICAgICAgICAgZmlyc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3RWYWx1ZTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGFzdFNlbGVjdGVkVmFsdWVcIiwgKGNvbGxlY3Rpb24pID0+IHtcbiAgICAgIGxldCBsYXN0VmFsdWUgPSBudWxsO1xuICAgICAgZm9yIChsZXQgdmFsdWUgb2YgdGhpcykge1xuICAgICAgICBpZiAoIWxhc3RWYWx1ZSB8fCBjb2xsZWN0aW9uLmNvbXBhcmVWYWx1ZSh2YWx1ZSwgbGFzdFZhbHVlKSA+IDApIHtcbiAgICAgICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RWYWx1ZTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZXh0ZW5kU2VsZWN0aW9uXCIsIChjb2xsZWN0aW9uLCBhbmNob3JWYWx1ZSwgdGFyZ2V0VmFsdWUpID0+IHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlU2VsZWN0aW9uKGNvbGxlY3Rpb24sIHRhcmdldFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuY29weSgpO1xuICAgICAgY29uc3QgbGFzdFNlbGVjdGVkID0gQXJyYXkuZnJvbSh0aGlzKS5wb3AoKTtcbiAgICAgIGZvciAobGV0IGtleSBvZiBjb2xsZWN0aW9uLmdldFZhbHVlUmFuZ2UoYW5jaG9yVmFsdWUsIGxhc3RTZWxlY3RlZCA/PyB0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgc2VsZWN0aW9uLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQga2V5IG9mIGNvbGxlY3Rpb24uZ2V0VmFsdWVSYW5nZSh0YXJnZXRWYWx1ZSwgYW5jaG9yVmFsdWUpKSB7XG4gICAgICAgIGlmICh0aGlzLmNhblNlbGVjdChjb2xsZWN0aW9uLCBrZXkpKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0b2dnbGVTZWxlY3Rpb25cIiwgKGNvbGxlY3Rpb24sIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIgJiYgIXRoaXMuaXNTZWxlY3RlZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVNlbGVjdGlvbihjb2xsZWN0aW9uLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmNvcHkoKTtcbiAgICAgIGlmIChzZWxlY3Rpb24uaGFzKHZhbHVlKSkge1xuICAgICAgICBzZWxlY3Rpb24uZGVsZXRlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uLmNhblNlbGVjdChjb2xsZWN0aW9uLCB2YWx1ZSkpIHtcbiAgICAgICAgc2VsZWN0aW9uLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXBsYWNlU2VsZWN0aW9uXCIsIChjb2xsZWN0aW9uLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jYW5TZWxlY3QoY29sbGVjdGlvbiwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbmV3IF9TZWxlY3Rpb24oW3ZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcy5zeW5jKHNlbGVjdGlvbik7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldFNlbGVjdGlvblwiLCAodmFsdWVzKSA9PiB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGxldCBzZWxlY3Rpb24gPSBuZXcgX1NlbGVjdGlvbigpO1xuICAgICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zeW5jKHNlbGVjdGlvbik7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNsZWFyU2VsZWN0aW9uXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuY29weSgpO1xuICAgICAgaWYgKHNlbGVjdGlvbi5kZXNlbGVjdGFibGUgJiYgc2VsZWN0aW9uLnNpemUgPiAwKSB7XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2VsZWN0XCIsIChjb2xsZWN0aW9uLCB2YWx1ZSwgZm9yY2VUb2dnbGUpID0+IHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikge1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKHZhbHVlKSAmJiB0aGlzLmRlc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZVNlbGVjdGlvbihjb2xsZWN0aW9uLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVNlbGVjdGlvbihjb2xsZWN0aW9uLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm11bHRpcGxlXCIgfHwgZm9yY2VUb2dnbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlU2VsZWN0aW9uKGNvbGxlY3Rpb24sIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VTZWxlY3Rpb24oY29sbGVjdGlvbiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkZXNlbGVjdFwiLCAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuY29weSgpO1xuICAgICAgc2VsZWN0aW9uLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc0VxdWFsXCIsIChvdGhlcikgPT4ge1xuICAgICAgcmV0dXJuIGlzRXF1YWwoQXJyYXkuZnJvbSh0aGlzKSwgQXJyYXkuZnJvbShvdGhlcikpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdHJlZS12aXNpdC50c1xuZnVuY3Rpb24gYWNjZXNzKG5vZGUsIGluZGV4UGF0aCwgb3B0aW9ucykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4UGF0aC5sZW5ndGg7IGkrKykgbm9kZSA9IG9wdGlvbnMuZ2V0Q2hpbGRyZW4obm9kZSwgaW5kZXhQYXRoLnNsaWNlKGkgKyAxKSlbaW5kZXhQYXRoW2ldXTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhbmNlc3RvckluZGV4UGF0aHMoaW5kZXhQYXRocykge1xuICBjb25zdCBzb3J0ZWRQYXRocyA9IHNvcnRJbmRleFBhdGhzKGluZGV4UGF0aHMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgaW5kZXhQYXRoIG9mIHNvcnRlZFBhdGhzKSB7XG4gICAgY29uc3Qga2V5ID0gaW5kZXhQYXRoLmpvaW4oKTtcbiAgICBpZiAoIXNlZW4uaGFzKGtleSkpIHtcbiAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICByZXN1bHQucHVzaChpbmRleFBhdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcGFyZUluZGV4UGF0aHMoYSwgYikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7IGkrKykge1xuICAgIGlmIChhW2ldIDwgYltpXSkgcmV0dXJuIC0xO1xuICAgIGlmIChhW2ldID4gYltpXSkgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG59XG5mdW5jdGlvbiBzb3J0SW5kZXhQYXRocyhpbmRleFBhdGhzKSB7XG4gIHJldHVybiBpbmRleFBhdGhzLnNvcnQoY29tcGFyZUluZGV4UGF0aHMpO1xufVxuZnVuY3Rpb24gZmluZChub2RlLCBvcHRpb25zKSB7XG4gIGxldCBmb3VuZDtcbiAgdmlzaXQobm9kZSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgb25FbnRlcjogKGNoaWxkLCBpbmRleFBhdGgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnByZWRpY2F0ZShjaGlsZCwgaW5kZXhQYXRoKSkge1xuICAgICAgICBmb3VuZCA9IGNoaWxkO1xuICAgICAgICByZXR1cm4gXCJzdG9wXCI7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gZmluZEFsbChub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvdW5kID0gW107XG4gIHZpc2l0KG5vZGUsIHtcbiAgICBvbkVudGVyOiAoY2hpbGQsIGluZGV4UGF0aCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMucHJlZGljYXRlKGNoaWxkLCBpbmRleFBhdGgpKSBmb3VuZC5wdXNoKGNoaWxkKTtcbiAgICB9LFxuICAgIGdldENoaWxkcmVuOiBvcHRpb25zLmdldENoaWxkcmVuXG4gIH0pO1xuICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBmaW5kSW5kZXhQYXRoKG5vZGUsIG9wdGlvbnMpIHtcbiAgbGV0IGZvdW5kO1xuICB2aXNpdChub2RlLCB7XG4gICAgb25FbnRlcjogKGNoaWxkLCBpbmRleFBhdGgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnByZWRpY2F0ZShjaGlsZCwgaW5kZXhQYXRoKSkge1xuICAgICAgICBmb3VuZCA9IFsuLi5pbmRleFBhdGhdO1xuICAgICAgICByZXR1cm4gXCJzdG9wXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRDaGlsZHJlbjogb3B0aW9ucy5nZXRDaGlsZHJlblxuICB9KTtcbiAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gcmVkdWNlKG5vZGUsIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VsdCA9IG9wdGlvbnMuaW5pdGlhbFJlc3VsdDtcbiAgdmlzaXQobm9kZSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgb25FbnRlcjogKGNoaWxkLCBpbmRleFBhdGgpID0+IHtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbnMubmV4dFJlc3VsdChyZXN1bHQsIGNoaWxkLCBpbmRleFBhdGgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmbGF0TWFwKG5vZGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlZHVjZShub2RlLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBpbml0aWFsUmVzdWx0OiBbXSxcbiAgICBuZXh0UmVzdWx0OiAocmVzdWx0LCBjaGlsZCwgaW5kZXhQYXRoKSA9PiB7XG4gICAgICByZXN1bHQucHVzaCguLi5vcHRpb25zLnRyYW5zZm9ybShjaGlsZCwgaW5kZXhQYXRoKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBmaWx0ZXIobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCB7IHByZWRpY2F0ZSwgY3JlYXRlLCBnZXRDaGlsZHJlbiB9ID0gb3B0aW9ucztcbiAgY29uc3QgZmlsdGVyUmVjdXJzaXZlID0gKG5vZGUyLCBpbmRleFBhdGgpID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKG5vZGUyLCBpbmRleFBhdGgpO1xuICAgIGNvbnN0IGZpbHRlcmVkQ2hpbGRyZW4gPSBbXTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkSW5kZXhQYXRoID0gWy4uLmluZGV4UGF0aCwgaW5kZXhdO1xuICAgICAgY29uc3QgZmlsdGVyZWRDaGlsZCA9IGZpbHRlclJlY3Vyc2l2ZShjaGlsZCwgY2hpbGRJbmRleFBhdGgpO1xuICAgICAgaWYgKGZpbHRlcmVkQ2hpbGQpIGZpbHRlcmVkQ2hpbGRyZW4ucHVzaChmaWx0ZXJlZENoaWxkKTtcbiAgICB9KTtcbiAgICBjb25zdCBpc1Jvb3QgPSBpbmRleFBhdGgubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IG5vZGVNYXRjaGVzID0gcHJlZGljYXRlKG5vZGUyLCBpbmRleFBhdGgpO1xuICAgIGNvbnN0IGhhc0ZpbHRlcmVkQ2hpbGRyZW4gPSBmaWx0ZXJlZENoaWxkcmVuLmxlbmd0aCA+IDA7XG4gICAgaWYgKGlzUm9vdCB8fCBub2RlTWF0Y2hlcyB8fCBoYXNGaWx0ZXJlZENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY3JlYXRlKG5vZGUyLCBmaWx0ZXJlZENoaWxkcmVuLCBpbmRleFBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIGZpbHRlclJlY3Vyc2l2ZShub2RlLCBbXSkgfHwgY3JlYXRlKG5vZGUsIFtdLCBbXSk7XG59XG5mdW5jdGlvbiBmbGF0dGVuKHJvb3ROb2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGxldCBpZHggPSAwO1xuICBjb25zdCBpZHhNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBwYXJlbnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB2aXNpdChyb290Tm9kZSwge1xuICAgIGdldENoaWxkcmVuOiBvcHRpb25zLmdldENoaWxkcmVuLFxuICAgIG9uRW50ZXI6IChub2RlLCBpbmRleFBhdGgpID0+IHtcbiAgICAgIGlmICghaWR4TWFwLmhhcyhub2RlKSkge1xuICAgICAgICBpZHhNYXAuc2V0KG5vZGUsIGlkeCsrKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gb3B0aW9ucy5nZXRDaGlsZHJlbihub2RlLCBpbmRleFBhdGgpO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKCFwYXJlbnRNYXAuaGFzKGNoaWxkKSkge1xuICAgICAgICAgIHBhcmVudE1hcC5zZXQoY2hpbGQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaWR4TWFwLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICBpZHhNYXAuc2V0KGNoaWxkLCBpZHgrKyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgX2NoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID4gMCA/IGNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGlkeE1hcC5nZXQoY2hpbGQpKSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudE1hcC5nZXQobm9kZSk7XG4gICAgICBjb25zdCBfcGFyZW50ID0gcGFyZW50ID8gaWR4TWFwLmdldChwYXJlbnQpIDogdm9pZCAwO1xuICAgICAgY29uc3QgX2luZGV4ID0gaWR4TWFwLmdldChub2RlKTtcbiAgICAgIG5vZGVzLnB1c2goeyAuLi5ub2RlLCBfY2hpbGRyZW4sIF9wYXJlbnQsIF9pbmRleCB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBpbnNlcnRPcGVyYXRpb24oaW5kZXgsIG5vZGVzKSB7XG4gIHJldHVybiB7IHR5cGU6IFwiaW5zZXJ0XCIsIGluZGV4LCBub2RlcyB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlT3BlcmF0aW9uKGluZGV4ZXMpIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJyZW1vdmVcIiwgaW5kZXhlcyB9O1xufVxuZnVuY3Rpb24gcmVwbGFjZU9wZXJhdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJyZXBsYWNlXCIgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0SW5kZXhQYXRoKGluZGV4UGF0aCkge1xuICByZXR1cm4gW2luZGV4UGF0aC5zbGljZSgwLCAtMSksIGluZGV4UGF0aFtpbmRleFBhdGgubGVuZ3RoIC0gMV1dO1xufVxuZnVuY3Rpb24gZ2V0SW5zZXJ0aW9uT3BlcmF0aW9ucyhpbmRleFBhdGgsIG5vZGVzLCBvcGVyYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSkge1xuICBjb25zdCBbcGFyZW50SW5kZXhQYXRoLCBpbmRleF0gPSBzcGxpdEluZGV4UGF0aChpbmRleFBhdGgpO1xuICBmb3IgKGxldCBpID0gcGFyZW50SW5kZXhQYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50SW5kZXhQYXRoLnNsaWNlKDAsIGkpLmpvaW4oKTtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbnMuZ2V0KHBhcmVudEtleSk/LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG9wZXJhdGlvbnMuc2V0KHBhcmVudEtleSwgcmVwbGFjZU9wZXJhdGlvbigpKTtcbiAgfVxuICBjb25zdCBvcGVyYXRpb24gPSBvcGVyYXRpb25zLmdldChwYXJlbnRJbmRleFBhdGguam9pbigpKTtcbiAgc3dpdGNoIChvcGVyYXRpb24/LnR5cGUpIHtcbiAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICBvcGVyYXRpb25zLnNldChwYXJlbnRJbmRleFBhdGguam9pbigpLCB7XG4gICAgICAgIHR5cGU6IFwicmVtb3ZlVGhlbkluc2VydFwiLFxuICAgICAgICByZW1vdmVJbmRleGVzOiBvcGVyYXRpb24uaW5kZXhlcyxcbiAgICAgICAgaW5zZXJ0SW5kZXg6IGluZGV4LFxuICAgICAgICBpbnNlcnROb2Rlczogbm9kZXNcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG9wZXJhdGlvbnMuc2V0KHBhcmVudEluZGV4UGF0aC5qb2luKCksIGluc2VydE9wZXJhdGlvbihpbmRleCwgbm9kZXMpKTtcbiAgfVxuICByZXR1cm4gb3BlcmF0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFJlbW92YWxPcGVyYXRpb25zKGluZGV4UGF0aHMpIHtcbiAgY29uc3Qgb3BlcmF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGluZGV4ZXNUb1JlbW92ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgaW5kZXhQYXRoIG9mIGluZGV4UGF0aHMpIHtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBpbmRleFBhdGguc2xpY2UoMCwgLTEpLmpvaW4oKTtcbiAgICBjb25zdCB2YWx1ZSA9IGluZGV4ZXNUb1JlbW92ZS5nZXQocGFyZW50S2V5KSA/PyBbXTtcbiAgICB2YWx1ZS5wdXNoKGluZGV4UGF0aFtpbmRleFBhdGgubGVuZ3RoIC0gMV0pO1xuICAgIGluZGV4ZXNUb1JlbW92ZS5zZXQoXG4gICAgICBwYXJlbnRLZXksXG4gICAgICB2YWx1ZS5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3QgaW5kZXhQYXRoIG9mIGluZGV4UGF0aHMpIHtcbiAgICBmb3IgKGxldCBpID0gaW5kZXhQYXRoLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBpbmRleFBhdGguc2xpY2UoMCwgaSkuam9pbigpO1xuICAgICAgaWYgKCFvcGVyYXRpb25zLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICAgIG9wZXJhdGlvbnMuc2V0KHBhcmVudEtleSwgcmVwbGFjZU9wZXJhdGlvbigpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBbcGFyZW50S2V5LCBpbmRleGVzXSBvZiBpbmRleGVzVG9SZW1vdmUpIHtcbiAgICBvcGVyYXRpb25zLnNldChwYXJlbnRLZXksIHJlbW92ZU9wZXJhdGlvbihpbmRleGVzKSk7XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRSZXBsYWNlT3BlcmF0aW9ucyhpbmRleFBhdGgsIG5vZGUpIHtcbiAgY29uc3Qgb3BlcmF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IFtwYXJlbnRJbmRleFBhdGgsIGluZGV4XSA9IHNwbGl0SW5kZXhQYXRoKGluZGV4UGF0aCk7XG4gIGZvciAobGV0IGkgPSBwYXJlbnRJbmRleFBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnRJbmRleFBhdGguc2xpY2UoMCwgaSkuam9pbigpO1xuICAgIG9wZXJhdGlvbnMuc2V0KHBhcmVudEtleSwgcmVwbGFjZU9wZXJhdGlvbigpKTtcbiAgfVxuICBvcGVyYXRpb25zLnNldChwYXJlbnRJbmRleFBhdGguam9pbigpLCB7XG4gICAgdHlwZTogXCJyZW1vdmVUaGVuSW5zZXJ0XCIsXG4gICAgcmVtb3ZlSW5kZXhlczogW2luZGV4XSxcbiAgICBpbnNlcnRJbmRleDogaW5kZXgsXG4gICAgaW5zZXJ0Tm9kZXM6IFtub2RlXVxuICB9KTtcbiAgcmV0dXJuIG9wZXJhdGlvbnM7XG59XG5mdW5jdGlvbiBtdXRhdGUobm9kZSwgb3BlcmF0aW9ucywgb3B0aW9ucykge1xuICByZXR1cm4gbWFwKG5vZGUsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGdldENoaWxkcmVuOiAobm9kZTIsIGluZGV4UGF0aCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gaW5kZXhQYXRoLmpvaW4oKTtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvbnMuZ2V0KGtleSk7XG4gICAgICBzd2l0Y2ggKG9wZXJhdGlvbj8udHlwZSkge1xuICAgICAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgIGNhc2UgXCJyZW1vdmVUaGVuSW5zZXJ0XCI6XG4gICAgICAgIGNhc2UgXCJpbnNlcnRcIjpcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5nZXRDaGlsZHJlbihub2RlMiwgaW5kZXhQYXRoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IChub2RlMiwgY2hpbGRyZW4sIGluZGV4UGF0aCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gaW5kZXhQYXRoLmpvaW4oKTtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvbnMuZ2V0KGtleSk7XG4gICAgICBzd2l0Y2ggKG9wZXJhdGlvbj8udHlwZSkge1xuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY3JlYXRlKFxuICAgICAgICAgICAgbm9kZTIsXG4gICAgICAgICAgICBjaGlsZHJlbi5maWx0ZXIoKF8sIGluZGV4KSA9PiAhb3BlcmF0aW9uLmluZGV4ZXMuaW5jbHVkZXMoaW5kZXgpKSxcbiAgICAgICAgICAgIGluZGV4UGF0aFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVUaGVuSW5zZXJ0XCI6XG4gICAgICAgICAgY29uc3QgdXBkYXRlZENoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKChfLCBpbmRleCkgPT4gIW9wZXJhdGlvbi5yZW1vdmVJbmRleGVzLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICAgICAgY29uc3QgYWRqdXN0ZWRJbmRleCA9IG9wZXJhdGlvbi5yZW1vdmVJbmRleGVzLnJlZHVjZShcbiAgICAgICAgICAgIChpbmRleCwgcmVtb3ZlZEluZGV4KSA9PiByZW1vdmVkSW5kZXggPCBpbmRleCA/IGluZGV4IC0gMSA6IGluZGV4LFxuICAgICAgICAgICAgb3BlcmF0aW9uLmluc2VydEluZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jcmVhdGUobm9kZTIsIHNwbGljZSh1cGRhdGVkQ2hpbGRyZW4sIGFkanVzdGVkSW5kZXgsIDAsIC4uLm9wZXJhdGlvbi5pbnNlcnROb2RlcyksIGluZGV4UGF0aCk7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRcIjpcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jcmVhdGUobm9kZTIsIHNwbGljZShjaGlsZHJlbiwgb3BlcmF0aW9uLmluZGV4LCAwLCAuLi5vcGVyYXRpb24ubm9kZXMpLCBpbmRleFBhdGgpO1xuICAgICAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNyZWF0ZShub2RlMiwgY2hpbGRyZW4sIGluZGV4UGF0aCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzcGxpY2UoYXJyYXksIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgcmV0dXJuIFsuLi5hcnJheS5zbGljZSgwLCBzdGFydCksIC4uLml0ZW1zLCAuLi5hcnJheS5zbGljZShzdGFydCArIGRlbGV0ZUNvdW50KV07XG59XG5mdW5jdGlvbiBtYXAobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCBjaGlsZHJlbk1hcCA9IHt9O1xuICB2aXNpdChub2RlLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBvbkxlYXZlOiAoY2hpbGQsIGluZGV4UGF0aCkgPT4ge1xuICAgICAgY29uc3Qga2V5SW5kZXhQYXRoID0gWzAsIC4uLmluZGV4UGF0aF07XG4gICAgICBjb25zdCBrZXkgPSBrZXlJbmRleFBhdGguam9pbigpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBvcHRpb25zLnRyYW5zZm9ybShjaGlsZCwgY2hpbGRyZW5NYXBba2V5XSA/PyBbXSwgaW5kZXhQYXRoKTtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IGtleUluZGV4UGF0aC5zbGljZSgwLCAtMSkuam9pbigpO1xuICAgICAgY29uc3QgcGFyZW50Q2hpbGRyZW4gPSBjaGlsZHJlbk1hcFtwYXJlbnRLZXldID8/IFtdO1xuICAgICAgcGFyZW50Q2hpbGRyZW4ucHVzaCh0cmFuc2Zvcm1lZCk7XG4gICAgICBjaGlsZHJlbk1hcFtwYXJlbnRLZXldID0gcGFyZW50Q2hpbGRyZW47XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNoaWxkcmVuTWFwW1wiXCJdWzBdO1xufVxuZnVuY3Rpb24gaW5zZXJ0Mihub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgbm9kZXMsIGF0IH0gPSBvcHRpb25zO1xuICBpZiAoYXQubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGluc2VydCBub2RlcyBhdCB0aGUgcm9vdGApO1xuICBjb25zdCBzdGF0ZSA9IGdldEluc2VydGlvbk9wZXJhdGlvbnMoYXQsIG5vZGVzKTtcbiAgcmV0dXJuIG11dGF0ZShub2RlLCBzdGF0ZSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZXBsYWNlKG5vZGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYXQubGVuZ3RoID09PSAwKSByZXR1cm4gb3B0aW9ucy5ub2RlO1xuICBjb25zdCBvcGVyYXRpb25zID0gZ2V0UmVwbGFjZU9wZXJhdGlvbnMob3B0aW9ucy5hdCwgb3B0aW9ucy5ub2RlKTtcbiAgcmV0dXJuIG11dGF0ZShub2RlLCBvcGVyYXRpb25zLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShub2RlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmluZGV4UGF0aHMubGVuZ3RoID09PSAwKSByZXR1cm4gbm9kZTtcbiAgZm9yIChjb25zdCBpbmRleFBhdGggb2Ygb3B0aW9ucy5pbmRleFBhdGhzKSB7XG4gICAgaWYgKGluZGV4UGF0aC5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcmVtb3ZlIHRoZSByb290IG5vZGVgKTtcbiAgfVxuICBjb25zdCBvcGVyYXRpb25zID0gZ2V0UmVtb3ZhbE9wZXJhdGlvbnMob3B0aW9ucy5pbmRleFBhdGhzKTtcbiAgcmV0dXJuIG11dGF0ZShub2RlLCBvcGVyYXRpb25zLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIG1vdmUyKG5vZGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuaW5kZXhQYXRocy5sZW5ndGggPT09IDApIHJldHVybiBub2RlO1xuICBmb3IgKGNvbnN0IGluZGV4UGF0aCBvZiBvcHRpb25zLmluZGV4UGF0aHMpIHtcbiAgICBpZiAoaW5kZXhQYXRoLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBtb3ZlIHRoZSByb290IG5vZGVgKTtcbiAgfVxuICBpZiAob3B0aW9ucy50by5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgbW92ZSBub2RlcyB0byB0aGUgcm9vdGApO1xuICBjb25zdCBfYW5jZXN0b3JJbmRleFBhdGhzID0gYW5jZXN0b3JJbmRleFBhdGhzKG9wdGlvbnMuaW5kZXhQYXRocyk7XG4gIGNvbnN0IG5vZGVzVG9JbnNlcnQgPSBfYW5jZXN0b3JJbmRleFBhdGhzLm1hcCgoaW5kZXhQYXRoKSA9PiBhY2Nlc3Mobm9kZSwgaW5kZXhQYXRoLCBvcHRpb25zKSk7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBnZXRJbnNlcnRpb25PcGVyYXRpb25zKG9wdGlvbnMudG8sIG5vZGVzVG9JbnNlcnQsIGdldFJlbW92YWxPcGVyYXRpb25zKF9hbmNlc3RvckluZGV4UGF0aHMpKTtcbiAgcmV0dXJuIG11dGF0ZShub2RlLCBvcGVyYXRpb25zLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBvbkVudGVyLCBvbkxlYXZlLCBnZXRDaGlsZHJlbiB9ID0gb3B0aW9ucztcbiAgbGV0IGluZGV4UGF0aCA9IFtdO1xuICBsZXQgc3RhY2sgPSBbeyBub2RlIH1dO1xuICBjb25zdCBnZXRJbmRleFBhdGggPSBvcHRpb25zLnJldXNlSW5kZXhQYXRoID8gKCkgPT4gaW5kZXhQYXRoIDogKCkgPT4gaW5kZXhQYXRoLnNsaWNlKCk7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgbGV0IHdyYXBwZXIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAod3JhcHBlci5zdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBlbnRlclJlc3VsdCA9IG9uRW50ZXI/Lih3cmFwcGVyLm5vZGUsIGdldEluZGV4UGF0aCgpKTtcbiAgICAgIGlmIChlbnRlclJlc3VsdCA9PT0gXCJzdG9wXCIpIHJldHVybjtcbiAgICAgIHdyYXBwZXIuc3RhdGUgPSBlbnRlclJlc3VsdCA9PT0gXCJza2lwXCIgPyAtMSA6IDA7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gd3JhcHBlci5jaGlsZHJlbiB8fCBnZXRDaGlsZHJlbih3cmFwcGVyLm5vZGUsIGdldEluZGV4UGF0aCgpKTtcbiAgICB3cmFwcGVyLmNoaWxkcmVuIHx8ICh3cmFwcGVyLmNoaWxkcmVuID0gY2hpbGRyZW4pO1xuICAgIGlmICh3cmFwcGVyLnN0YXRlICE9PSAtMSkge1xuICAgICAgaWYgKHdyYXBwZXIuc3RhdGUgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHdyYXBwZXIuc3RhdGU7XG4gICAgICAgIGluZGV4UGF0aC5wdXNoKGN1cnJlbnRJbmRleCk7XG4gICAgICAgIHN0YWNrLnB1c2goeyBub2RlOiBjaGlsZHJlbltjdXJyZW50SW5kZXhdIH0pO1xuICAgICAgICB3cmFwcGVyLnN0YXRlID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWF2ZVJlc3VsdCA9IG9uTGVhdmU/Lih3cmFwcGVyLm5vZGUsIGdldEluZGV4UGF0aCgpKTtcbiAgICAgIGlmIChsZWF2ZVJlc3VsdCA9PT0gXCJzdG9wXCIpIHJldHVybjtcbiAgICB9XG4gICAgaW5kZXhQYXRoLnBvcCgpO1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG59XG5cbi8vIHNyYy90cmVlLWNvbGxlY3Rpb24udHNcbnZhciBUcmVlQ29sbGVjdGlvbiA9IGNsYXNzIF9UcmVlQ29sbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyb290Tm9kZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNFcXVhbFwiLCAob3RoZXIpID0+IHtcbiAgICAgIHJldHVybiBpc0VxdWFsKHRoaXMucm9vdE5vZGUsIG90aGVyLnJvb3ROb2RlKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0Tm9kZUNoaWxkcmVuXCIsIChub2RlKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5vZGVUb0NoaWxkcmVuPy4obm9kZSkgPz8gZmFsbGJhY2tNZXRob2RzLm5vZGVUb0NoaWxkcmVuKG5vZGUpID8/IFtdO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXNvbHZlSW5kZXhQYXRoXCIsICh2YWx1ZU9ySW5kZXhQYXRoKSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlT3JJbmRleFBhdGggPT09IFwic3RyaW5nXCIgPyB0aGlzLmdldEluZGV4UGF0aCh2YWx1ZU9ySW5kZXhQYXRoKSA6IHZhbHVlT3JJbmRleFBhdGg7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlc29sdmVOb2RlXCIsICh2YWx1ZU9ySW5kZXhQYXRoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleFBhdGggPSB0aGlzLnJlc29sdmVJbmRleFBhdGgodmFsdWVPckluZGV4UGF0aCk7XG4gICAgICByZXR1cm4gaW5kZXhQYXRoID8gdGhpcy5hdChpbmRleFBhdGgpIDogdm9pZCAwO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXROb2RlQ2hpbGRyZW5Db3VudFwiLCAobm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ub2RlVG9DaGlsZHJlbkNvdW50Py4obm9kZSkgPz8gZmFsbGJhY2tNZXRob2RzLm5vZGVUb0NoaWxkcmVuQ291bnQobm9kZSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldE5vZGVWYWx1ZVwiLCAobm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ub2RlVG9WYWx1ZT8uKG5vZGUpID8/IGZhbGxiYWNrTWV0aG9kcy5ub2RlVG9WYWx1ZShub2RlKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0Tm9kZURpc2FibGVkXCIsIChub2RlKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlzTm9kZURpc2FibGVkPy4obm9kZSkgPz8gZmFsbGJhY2tNZXRob2RzLmlzTm9kZURpc2FibGVkKG5vZGUpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHJpbmdpZnlcIiwgKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5maW5kTm9kZSh2YWx1ZSk7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5Tm9kZShub2RlKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RyaW5naWZ5Tm9kZVwiLCAobm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ub2RlVG9TdHJpbmc/Lihub2RlKSA/PyBmYWxsYmFja01ldGhvZHMubm9kZVRvU3RyaW5nKG5vZGUpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRGaXJzdE5vZGVcIiwgKHJvb3ROb2RlID0gdGhpcy5yb290Tm9kZSkgPT4ge1xuICAgICAgbGV0IGZpcnN0Q2hpbGQ7XG4gICAgICB2aXNpdChyb290Tm9kZSwge1xuICAgICAgICBnZXRDaGlsZHJlbjogdGhpcy5nZXROb2RlQ2hpbGRyZW4sXG4gICAgICAgIG9uRW50ZXI6IChub2RlLCBpbmRleFBhdGgpID0+IHtcbiAgICAgICAgICBpZiAoIWZpcnN0Q2hpbGQgJiYgaW5kZXhQYXRoLmxlbmd0aCA+IDAgJiYgIXRoaXMuZ2V0Tm9kZURpc2FibGVkKG5vZGUpKSB7XG4gICAgICAgICAgICBmaXJzdENoaWxkID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBcInN0b3BcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldExhc3ROb2RlXCIsIChyb290Tm9kZSA9IHRoaXMucm9vdE5vZGUsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgbGV0IGxhc3RDaGlsZDtcbiAgICAgIHZpc2l0KHJvb3ROb2RlLCB7XG4gICAgICAgIGdldENoaWxkcmVuOiB0aGlzLmdldE5vZGVDaGlsZHJlbixcbiAgICAgICAgb25FbnRlcjogKG5vZGUsIGluZGV4UGF0aCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzU2FtZU5vZGUobm9kZSwgcm9vdE5vZGUpKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdHMuc2tpcD8uKHsgdmFsdWU6IHRoaXMuZ2V0Tm9kZVZhbHVlKG5vZGUpLCBub2RlLCBpbmRleFBhdGggfSkpIHJldHVybiBcInNraXBcIjtcbiAgICAgICAgICBpZiAoaW5kZXhQYXRoLmxlbmd0aCA+IDAgJiYgIXRoaXMuZ2V0Tm9kZURpc2FibGVkKG5vZGUpKSB7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbGFzdENoaWxkO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdFwiLCAoaW5kZXhQYXRoKSA9PiB7XG4gICAgICByZXR1cm4gYWNjZXNzKHRoaXMucm9vdE5vZGUsIGluZGV4UGF0aCwge1xuICAgICAgICBnZXRDaGlsZHJlbjogdGhpcy5nZXROb2RlQ2hpbGRyZW5cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaW5kTm9kZVwiLCAodmFsdWUsIHJvb3ROb2RlID0gdGhpcy5yb290Tm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbmQocm9vdE5vZGUsIHtcbiAgICAgICAgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLFxuICAgICAgICBwcmVkaWNhdGU6IChub2RlKSA9PiB0aGlzLmdldE5vZGVWYWx1ZShub2RlKSA9PT0gdmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaW5kTm9kZXNcIiwgKHZhbHVlcywgcm9vdE5vZGUgPSB0aGlzLnJvb3ROb2RlKSA9PiB7XG4gICAgICBjb25zdCB2ID0gbmV3IFNldCh2YWx1ZXMuZmlsdGVyKCh2MikgPT4gdjIgIT0gbnVsbCkpO1xuICAgICAgcmV0dXJuIGZpbmRBbGwocm9vdE5vZGUsIHtcbiAgICAgICAgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLFxuICAgICAgICBwcmVkaWNhdGU6IChub2RlKSA9PiB2Lmhhcyh0aGlzLmdldE5vZGVWYWx1ZShub2RlKSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzb3J0XCIsICh2YWx1ZXMpID0+IHtcbiAgICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4UGF0aCA9IHRoaXMuZ2V0SW5kZXhQYXRoKHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4UGF0aCkgYWNjLnB1c2goeyB2YWx1ZSwgaW5kZXhQYXRoIH0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgW10pLnNvcnQoKGEsIGIpID0+IGNvbXBhcmVJbmRleFBhdGhzKGEuaW5kZXhQYXRoLCBiLmluZGV4UGF0aCkpLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldEluZGV4UGF0aFwiLCAodmFsdWUpID0+IHtcbiAgICAgIHJldHVybiBmaW5kSW5kZXhQYXRoKHRoaXMucm9vdE5vZGUsIHtcbiAgICAgICAgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLFxuICAgICAgICBwcmVkaWNhdGU6IChub2RlKSA9PiB0aGlzLmdldE5vZGVWYWx1ZShub2RlKSA9PT0gdmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRWYWx1ZVwiLCAoaW5kZXhQYXRoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5hdChpbmRleFBhdGgpO1xuICAgICAgcmV0dXJuIG5vZGUgPyB0aGlzLmdldE5vZGVWYWx1ZShub2RlKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0VmFsdWVQYXRoXCIsIChpbmRleFBhdGgpID0+IHtcbiAgICAgIGlmICghaW5kZXhQYXRoKSByZXR1cm4gW107XG4gICAgICBjb25zdCB2YWx1ZVBhdGggPSBbXTtcbiAgICAgIGxldCBjdXJyZW50UGF0aCA9IFsuLi5pbmRleFBhdGhdO1xuICAgICAgd2hpbGUgKGN1cnJlbnRQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuYXQoY3VycmVudFBhdGgpO1xuICAgICAgICBpZiAobm9kZSkgdmFsdWVQYXRoLnVuc2hpZnQodGhpcy5nZXROb2RlVmFsdWUobm9kZSkpO1xuICAgICAgICBjdXJyZW50UGF0aC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVBhdGg7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldERlcHRoXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXhQYXRoID0gZmluZEluZGV4UGF0aCh0aGlzLnJvb3ROb2RlLCB7XG4gICAgICAgIGdldENoaWxkcmVuOiB0aGlzLmdldE5vZGVDaGlsZHJlbixcbiAgICAgICAgcHJlZGljYXRlOiAobm9kZSkgPT4gdGhpcy5nZXROb2RlVmFsdWUobm9kZSkgPT09IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbmRleFBhdGg/Lmxlbmd0aCA/PyAwO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc1NhbWVOb2RlXCIsIChub2RlLCBvdGhlcikgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZVZhbHVlKG5vZGUpID09PSB0aGlzLmdldE5vZGVWYWx1ZShvdGhlcik7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzUm9vdE5vZGVcIiwgKG5vZGUpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmlzU2FtZU5vZGUobm9kZSwgdGhpcy5yb290Tm9kZSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbnRhaW5zXCIsIChwYXJlbnRJbmRleFBhdGgsIHZhbHVlSW5kZXhQYXRoKSA9PiB7XG4gICAgICBpZiAoIXBhcmVudEluZGV4UGF0aCB8fCAhdmFsdWVJbmRleFBhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB2YWx1ZUluZGV4UGF0aC5zbGljZSgwLCBwYXJlbnRJbmRleFBhdGgubGVuZ3RoKS5ldmVyeSgoXywgaSkgPT4gcGFyZW50SW5kZXhQYXRoW2ldID09PSB2YWx1ZUluZGV4UGF0aFtpXSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldE5leHROb2RlXCIsICh2YWx1ZSwgb3B0cyA9IHt9KSA9PiB7XG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgIGxldCBuZXh0Tm9kZTtcbiAgICAgIHZpc2l0KHRoaXMucm9vdE5vZGUsIHtcbiAgICAgICAgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLFxuICAgICAgICBvbkVudGVyOiAobm9kZSwgaW5kZXhQYXRoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNSb290Tm9kZShub2RlKSkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRoaXMuZ2V0Tm9kZVZhbHVlKG5vZGUpO1xuICAgICAgICAgIGlmIChvcHRzLnNraXA/Lih7IHZhbHVlOiBub2RlVmFsdWUsIG5vZGUsIGluZGV4UGF0aCB9KSkge1xuICAgICAgICAgICAgaWYgKG5vZGVWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwic2tpcFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm91bmQgJiYgIXRoaXMuZ2V0Tm9kZURpc2FibGVkKG5vZGUpKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gXCJzdG9wXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0UHJldmlvdXNOb2RlXCIsICh2YWx1ZSwgb3B0cyA9IHt9KSA9PiB7XG4gICAgICBsZXQgcHJldmlvdXNOb2RlO1xuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICB2aXNpdCh0aGlzLnJvb3ROb2RlLCB7XG4gICAgICAgIGdldENoaWxkcmVuOiB0aGlzLmdldE5vZGVDaGlsZHJlbixcbiAgICAgICAgb25FbnRlcjogKG5vZGUsIGluZGV4UGF0aCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzUm9vdE5vZGUobm9kZSkpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBub2RlVmFsdWUgPSB0aGlzLmdldE5vZGVWYWx1ZShub2RlKTtcbiAgICAgICAgICBpZiAob3B0cy5za2lwPy4oeyB2YWx1ZTogbm9kZVZhbHVlLCBub2RlLCBpbmRleFBhdGggfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcInNraXBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGVWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBcInN0b3BcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmdldE5vZGVEaXNhYmxlZChub2RlKSkge1xuICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kID8gcHJldmlvdXNOb2RlIDogdm9pZCAwO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRQYXJlbnROb2Rlc1wiLCAodmFsdWVPckluZGV4UGF0aCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXhQYXRoID0gdGhpcy5yZXNvbHZlSW5kZXhQYXRoKHZhbHVlT3JJbmRleFBhdGgpPy5zbGljZSgpO1xuICAgICAgaWYgKCFpbmRleFBhdGgpIHJldHVybiBbXTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgd2hpbGUgKGluZGV4UGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGluZGV4UGF0aC5wb3AoKTtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuYXQoaW5kZXhQYXRoKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgIXRoaXMuaXNSb290Tm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHBhcmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXREZXNjZW5kYW50Tm9kZXNcIiwgKHZhbHVlT3JJbmRleFBhdGgsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0aGlzLnJlc29sdmVOb2RlKHZhbHVlT3JJbmRleFBhdGgpO1xuICAgICAgaWYgKCFwYXJlbnROb2RlKSByZXR1cm4gW107XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIHZpc2l0KHBhcmVudE5vZGUsIHtcbiAgICAgICAgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLFxuICAgICAgICBvbkVudGVyOiAobm9kZSwgbm9kZUluZGV4UGF0aCkgPT4ge1xuICAgICAgICAgIGlmIChub2RlSW5kZXhQYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAgIGlmICghb3B0aW9ucz8ud2l0aEJyYW5jaCAmJiB0aGlzLmlzQnJhbmNoTm9kZShub2RlKSkgcmV0dXJuO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldERlc2NlbmRhbnRWYWx1ZXNcIiwgKHZhbHVlT3JJbmRleFBhdGgsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXREZXNjZW5kYW50Tm9kZXModmFsdWVPckluZGV4UGF0aCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gdGhpcy5nZXROb2RlVmFsdWUoY2hpbGQpKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0UGFyZW50SW5kZXhQYXRoXCIsIChpbmRleFBhdGgpID0+IHtcbiAgICAgIHJldHVybiBpbmRleFBhdGguc2xpY2UoMCwgLTEpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRQYXJlbnROb2RlXCIsICh2YWx1ZU9ySW5kZXhQYXRoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleFBhdGggPSB0aGlzLnJlc29sdmVJbmRleFBhdGgodmFsdWVPckluZGV4UGF0aCk7XG4gICAgICByZXR1cm4gaW5kZXhQYXRoID8gdGhpcy5hdCh0aGlzLmdldFBhcmVudEluZGV4UGF0aChpbmRleFBhdGgpKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmlzaXRcIiwgKG9wdHMpID0+IHtcbiAgICAgIGNvbnN0IHsgc2tpcCwgLi4ucmVzdCB9ID0gb3B0cztcbiAgICAgIHZpc2l0KHRoaXMucm9vdE5vZGUsIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLFxuICAgICAgICBvbkVudGVyOiAobm9kZSwgaW5kZXhQYXRoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNSb290Tm9kZShub2RlKSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChza2lwPy4oeyB2YWx1ZTogdGhpcy5nZXROb2RlVmFsdWUobm9kZSksIG5vZGUsIGluZGV4UGF0aCB9KSkgcmV0dXJuIFwic2tpcFwiO1xuICAgICAgICAgIHJldHVybiByZXN0Lm9uRW50ZXI/Lihub2RlLCBpbmRleFBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0UHJldmlvdXNTaWJsaW5nXCIsIChpbmRleFBhdGgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0aGlzLmdldFBhcmVudE5vZGUoaW5kZXhQYXRoKTtcbiAgICAgIGlmICghcGFyZW50Tm9kZSkgcmV0dXJuO1xuICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLmdldE5vZGVDaGlsZHJlbihwYXJlbnROb2RlKTtcbiAgICAgIGxldCBpZHggPSBpbmRleFBhdGhbaW5kZXhQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgd2hpbGUgKC0taWR4ID49IDApIHtcbiAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2lkeF07XG4gICAgICAgIGlmICghdGhpcy5nZXROb2RlRGlzYWJsZWQoc2libGluZykpIHJldHVybiBzaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXROZXh0U2libGluZ1wiLCAoaW5kZXhQYXRoKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5nZXRQYXJlbnROb2RlKGluZGV4UGF0aCk7XG4gICAgICBpZiAoIXBhcmVudE5vZGUpIHJldHVybjtcbiAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5nZXROb2RlQ2hpbGRyZW4ocGFyZW50Tm9kZSk7XG4gICAgICBsZXQgaWR4ID0gaW5kZXhQYXRoW2luZGV4UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIHdoaWxlICgrK2lkeCA8IHNpYmxpbmdzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaWR4XTtcbiAgICAgICAgaWYgKCF0aGlzLmdldE5vZGVEaXNhYmxlZChzaWJsaW5nKSkgcmV0dXJuIHNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFNpYmxpbmdOb2Rlc1wiLCAoaW5kZXhQYXRoKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5nZXRQYXJlbnROb2RlKGluZGV4UGF0aCk7XG4gICAgICByZXR1cm4gcGFyZW50Tm9kZSA/IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuKHBhcmVudE5vZGUpIDogW107XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFZhbHVlc1wiLCAocm9vdE5vZGUgPSB0aGlzLnJvb3ROb2RlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBmbGF0TWFwKHJvb3ROb2RlLCB7XG4gICAgICAgIGdldENoaWxkcmVuOiB0aGlzLmdldE5vZGVDaGlsZHJlbixcbiAgICAgICAgdHJhbnNmb3JtOiAobm9kZSkgPT4gW3RoaXMuZ2V0Tm9kZVZhbHVlKG5vZGUpXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmFsdWVzLnNsaWNlKDEpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc1NhbWVEZXB0aFwiLCAoaW5kZXhQYXRoLCBkZXB0aCkgPT4ge1xuICAgICAgaWYgKGRlcHRoID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGluZGV4UGF0aC5sZW5ndGggPT09IGRlcHRoO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc0JyYW5jaE5vZGVcIiwgKG5vZGUpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5vZGVDaGlsZHJlbihub2RlKS5sZW5ndGggPiAwIHx8IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuQ291bnQobm9kZSkgIT0gbnVsbDtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0QnJhbmNoVmFsdWVzXCIsIChyb290Tm9kZSA9IHRoaXMucm9vdE5vZGUsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgdmlzaXQocm9vdE5vZGUsIHtcbiAgICAgICAgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLFxuICAgICAgICBvbkVudGVyOiAobm9kZSwgaW5kZXhQYXRoKSA9PiB7XG4gICAgICAgICAgaWYgKGluZGV4UGF0aC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgICBjb25zdCBub2RlVmFsdWUgPSB0aGlzLmdldE5vZGVWYWx1ZShub2RlKTtcbiAgICAgICAgICBpZiAob3B0cy5za2lwPy4oeyB2YWx1ZTogbm9kZVZhbHVlLCBub2RlLCBpbmRleFBhdGggfSkpIHJldHVybiBcInNraXBcIjtcbiAgICAgICAgICBpZiAodGhpcy5pc0JyYW5jaE5vZGUobm9kZSkgJiYgdGhpcy5pc1NhbWVEZXB0aChpbmRleFBhdGgsIG9wdHMuZGVwdGgpKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmdldE5vZGVWYWx1ZShub2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZsYXR0ZW5cIiwgKHJvb3ROb2RlID0gdGhpcy5yb290Tm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIGZsYXR0ZW4ocm9vdE5vZGUsIHsgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfY3JlYXRlXCIsIChub2RlLCBjaGlsZHJlbikgPT4ge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoeyAuLi5ub2RlLCBjaGlsZHJlbjogY2hpbGRyZW4ubGVuZ3RoID4gMCA/IGNoaWxkcmVuIDogdm9pZCAwIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaW5zZXJ0XCIsIChyb290Tm9kZSwgaW5kZXhQYXRoLCBub2RlcykgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY29weShcbiAgICAgICAgaW5zZXJ0Mihyb290Tm9kZSwgeyBhdDogaW5kZXhQYXRoLCBub2RlcywgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLCBjcmVhdGU6IHRoaXMuX2NyZWF0ZSB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29weVwiLCAocm9vdE5vZGUpID0+IHtcbiAgICAgIHJldHVybiBuZXcgX1RyZWVDb2xsZWN0aW9uKHsgLi4udGhpcy5vcHRpb25zLCByb290Tm9kZSB9KTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3JlcGxhY2VcIiwgKHJvb3ROb2RlLCBpbmRleFBhdGgsIG5vZGUpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcHkoXG4gICAgICAgIHJlcGxhY2Uocm9vdE5vZGUsIHsgYXQ6IGluZGV4UGF0aCwgbm9kZSwgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLCBjcmVhdGU6IHRoaXMuX2NyZWF0ZSB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX21vdmVcIiwgKHJvb3ROb2RlLCBpbmRleFBhdGhzLCB0bykgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY29weShtb3ZlMihyb290Tm9kZSwgeyBpbmRleFBhdGhzLCB0bywgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLCBjcmVhdGU6IHRoaXMuX2NyZWF0ZSB9KSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9yZW1vdmVcIiwgKHJvb3ROb2RlLCBpbmRleFBhdGhzKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KHJlbW92ZShyb290Tm9kZSwgeyBpbmRleFBhdGhzLCBnZXRDaGlsZHJlbjogdGhpcy5nZXROb2RlQ2hpbGRyZW4sIGNyZWF0ZTogdGhpcy5fY3JlYXRlIH0pKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVwbGFjZVwiLCAoaW5kZXhQYXRoLCBub2RlKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVwbGFjZSh0aGlzLnJvb3ROb2RlLCBpbmRleFBhdGgsIG5vZGUpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZW1vdmVcIiwgKGluZGV4UGF0aHMpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUodGhpcy5yb290Tm9kZSwgaW5kZXhQYXRocyk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluc2VydEJlZm9yZVwiLCAoaW5kZXhQYXRoLCBub2RlcykgPT4ge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuZ2V0UGFyZW50Tm9kZShpbmRleFBhdGgpO1xuICAgICAgcmV0dXJuIHBhcmVudE5vZGUgPyB0aGlzLl9pbnNlcnQodGhpcy5yb290Tm9kZSwgaW5kZXhQYXRoLCBub2RlcykgOiB2b2lkIDA7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluc2VydEFmdGVyXCIsIChpbmRleFBhdGgsIG5vZGVzKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5nZXRQYXJlbnROb2RlKGluZGV4UGF0aCk7XG4gICAgICBpZiAoIXBhcmVudE5vZGUpIHJldHVybjtcbiAgICAgIGNvbnN0IG5leHRJbmRleDIgPSBbLi4uaW5kZXhQYXRoLnNsaWNlKDAsIC0xKSwgaW5kZXhQYXRoW2luZGV4UGF0aC5sZW5ndGggLSAxXSArIDFdO1xuICAgICAgcmV0dXJuIHRoaXMuX2luc2VydCh0aGlzLnJvb3ROb2RlLCBuZXh0SW5kZXgyLCBub2Rlcyk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1vdmVcIiwgKGZyb21JbmRleFBhdGhzLCB0b0luZGV4UGF0aCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmUodGhpcy5yb290Tm9kZSwgZnJvbUluZGV4UGF0aHMsIHRvSW5kZXhQYXRoKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmlsdGVyXCIsIChwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUm9vdCA9IGZpbHRlcih0aGlzLnJvb3ROb2RlLCB7XG4gICAgICAgIHByZWRpY2F0ZSxcbiAgICAgICAgZ2V0Q2hpbGRyZW46IHRoaXMuZ2V0Tm9kZUNoaWxkcmVuLFxuICAgICAgICBjcmVhdGU6IHRoaXMuX2NyZWF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KGZpbHRlcmVkUm9vdCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRvSlNPTlwiLCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXModGhpcy5yb290Tm9kZSk7XG4gICAgfSk7XG4gICAgdGhpcy5yb290Tm9kZSA9IG9wdGlvbnMucm9vdE5vZGU7XG4gIH1cbn07XG5mdW5jdGlvbiBmbGF0dGVuZWRUb1RyZWUobm9kZXMsIG9wdGlvbnMgPSBmYWxsYmFja01ldGhvZHMpIHtcbiAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlt6YWctanMvdHJlZV0gQ2Fubm90IGNyZWF0ZSB0cmVlIGZyb20gZW1wdHkgZmxhdHRlbmVkIGFycmF5XCIpO1xuICB9XG4gIGNvbnN0IHJvb3RGbGF0Tm9kZSA9IG5vZGVzLmZpbmQoKG5vZGUpID0+IG5vZGUuX3BhcmVudCA9PT0gdm9pZCAwKTtcbiAgaWYgKCFyb290RmxhdE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbemFnLWpzL3RyZWVdIE5vIHJvb3Qgbm9kZSBmb3VuZCBpbiBmbGF0dGVuZWQgZGF0YVwiKTtcbiAgfVxuICBjb25zdCBub2RlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgIG5vZGVNYXAuc2V0KG5vZGUuX2luZGV4LCBub2RlKTtcbiAgfSk7XG4gIGNvbnN0IGJ1aWxkTm9kZSA9IChpZHgpID0+IHtcbiAgICBjb25zdCBmbGF0Tm9kZSA9IG5vZGVNYXAuZ2V0KGlkeCk7XG4gICAgaWYgKCFmbGF0Tm9kZSkgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgX2NoaWxkcmVuLCBfcGFyZW50LCBfaW5kZXgsIC4uLmNsZWFuTm9kZSB9ID0gZmxhdE5vZGU7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICBfY2hpbGRyZW4/LmZvckVhY2goKGNoaWxkSW5kZXgpID0+IHtcbiAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGROb2RlKGNoaWxkSW5kZXgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY2xlYW5Ob2RlLFxuICAgICAgLi4uY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiB7IGNoaWxkcmVuIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCByb290Tm9kZSA9IGJ1aWxkTm9kZShyb290RmxhdE5vZGUuX2luZGV4KTtcbiAgcmV0dXJuIG5ldyBUcmVlQ29sbGVjdGlvbih7IC4uLm9wdGlvbnMsIHJvb3ROb2RlIH0pO1xufVxuZnVuY3Rpb24gZmlsZVBhdGhUb1RyZWUocGF0aHMpIHtcbiAgY29uc3Qgcm9vdE5vZGUgPSB7XG4gICAgbGFiZWw6IFwiXCIsXG4gICAgdmFsdWU6IFwiUk9PVFwiLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9O1xuICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICBsZXQgY3VycmVudE5vZGUgPSByb290Tm9kZTtcbiAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgbGV0IGNoaWxkTm9kZSA9IGN1cnJlbnROb2RlLmNoaWxkcmVuPy5maW5kKChjaGlsZCkgPT4gY2hpbGQubGFiZWwgPT09IHBhcnQpO1xuICAgICAgaWYgKCFjaGlsZE5vZGUpIHtcbiAgICAgICAgY2hpbGROb2RlID0ge1xuICAgICAgICAgIHZhbHVlOiBwYXJ0cy5zbGljZSgwLCBpbmRleCArIDEpLmpvaW4oXCIvXCIpLFxuICAgICAgICAgIGxhYmVsOiBwYXJ0XG4gICAgICAgIH07XG4gICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuIHx8IChjdXJyZW50Tm9kZS5jaGlsZHJlbiA9IFtdKTtcbiAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4ucHVzaChjaGlsZE5vZGUpO1xuICAgICAgfVxuICAgICAgY3VycmVudE5vZGUgPSBjaGlsZE5vZGU7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gbmV3IFRyZWVDb2xsZWN0aW9uKHsgcm9vdE5vZGUgfSk7XG59XG52YXIgZmFsbGJhY2tNZXRob2RzID0ge1xuICBub2RlVG9WYWx1ZShub2RlKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSByZXR1cm4gbm9kZTtcbiAgICBpZiAoaXNPYmplY3Qobm9kZSkgJiYgaGFzUHJvcChub2RlLCBcInZhbHVlXCIpKSByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSxcbiAgbm9kZVRvU3RyaW5nKG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHJldHVybiBub2RlO1xuICAgIGlmIChpc09iamVjdChub2RlKSAmJiBoYXNQcm9wKG5vZGUsIFwibGFiZWxcIikpIHJldHVybiBub2RlLmxhYmVsO1xuICAgIHJldHVybiBmYWxsYmFja01ldGhvZHMubm9kZVRvVmFsdWUobm9kZSk7XG4gIH0sXG4gIGlzTm9kZURpc2FibGVkKG5vZGUpIHtcbiAgICBpZiAoaXNPYmplY3Qobm9kZSkgJiYgaGFzUHJvcChub2RlLCBcImRpc2FibGVkXCIpKSByZXR1cm4gISFub2RlLmRpc2FibGVkO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgbm9kZVRvQ2hpbGRyZW4obm9kZSkge1xuICAgIHJldHVybiBub2RlLmNoaWxkcmVuO1xuICB9LFxuICBub2RlVG9DaGlsZHJlbkNvdW50KG5vZGUpIHtcbiAgICBpZiAoaXNPYmplY3Qobm9kZSkgJiYgaGFzUHJvcChub2RlLCBcImNoaWxkcmVuQ291bnRcIikpIHJldHVybiBub2RlLmNoaWxkcmVuQ291bnQ7XG4gIH1cbn07XG5cbmV4cG9ydCB7IEdyaWRDb2xsZWN0aW9uLCBMaXN0Q29sbGVjdGlvbiwgU2VsZWN0aW9uLCBUcmVlQ29sbGVjdGlvbiwgZmlsZVBhdGhUb1RyZWUsIGZsYXR0ZW5lZFRvVHJlZSwgaXNHcmlkQ29sbGVjdGlvbiwgaXNMaXN0Q29sbGVjdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@zag-js+collection@1.18.2/node_modules/@zag-js/collection/dist/index.mjs\n");

/***/ })

};
;